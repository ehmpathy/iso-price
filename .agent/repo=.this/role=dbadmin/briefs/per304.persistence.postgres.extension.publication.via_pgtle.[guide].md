# publication via pg_tle

how to publish and consume the iso_price extension via pg_tle (trusted language extensions).

→ for overview, see [per304.overview](./per304.persistence.postgres.extension.publication._.[overview].md)

---

## tl;dr

pg_tle stores extension definitions **in the database** (not filesystem), then enables standard `CREATE EXTENSION` syntax.

```sql
-- 1. register (one-time by extension author)
SELECT pgtle.install_extension('iso_price', '1.0.0', 'description', $$ ... sql ... $$);

-- 2. install (by database user)
CREATE EXTENSION iso_price;
```

---

## how pg_tle works

### the problem

native postgresql extensions require files in `$SHAREDIR/extension/`:

```
/usr/share/postgresql/15/extension/
  iso_price.control
  iso_price--1.0.0.sql
```

managed postgres (rds, cloud sql, etc.) **blocks filesystem access** — you cannot write these files.

### the solution

pg_tle stores extension metadata in database tables instead of the filesystem:

```
pgtle.feature_info        # extension metadata (like .control file)
pgtle.available_extensions  # registered extensions
```

when you run `CREATE EXTENSION iso_price`, postgresql checks pg_tle's tables instead of the filesystem.

### scope: database-level (not cluster-level)

**pg_tle registration is per-database, not per-cluster.**

the `pgtle.feature_info` table lives inside each database. this means:

| action | scope |
|--------|-------|
| `CREATE EXTENSION pg_tle` | per-database |
| `pgtle.install_extension(...)` | per-database |
| `CREATE EXTENSION iso_price` | per-database |

**implication for multi-database clusters:**

```sql
-- database: app_production
CREATE EXTENSION pg_tle;
\i iso_price--1.0.0.pgtle.sql    -- registers in app_production only
CREATE EXTENSION iso_price;

-- database: app_staging (separate registration required)
\c app_staging
CREATE EXTENSION pg_tle;
\i iso_price--1.0.0.pgtle.sql    -- must register again
CREATE EXTENSION iso_price;
```

this differs from native filesystem extensions, which are cluster-wide (files in `$SHAREDIR` are visible to all databases).

### pg_tle vs raw sql: when is pg_tle worth it?

since pg_tle registration is per-database anyway, why not just use raw sql?

| feature | pg_tle | raw sql |
|---------|--------|---------|
| installation | 2 steps (register + create) | 1 step (run sql) |
| version visibility | `\dx` shows version | manual |
| upgrade path | `ALTER EXTENSION UPDATE` | manual migration |
| clean removal | `DROP EXTENSION` | manual drop sequence |
| dba familiarity | standard syntax | just sql |
| platform support | aws rds/aurora only | everywhere |

**pg_tle is worth it when:**
- you have dbas who expect `CREATE EXTENSION` workflow
- you want `\dx` to show installed extensions and versions
- you need `ALTER EXTENSION UPDATE` for version migrations
- you're already on aws rds/aurora

**raw sql is simpler when:**
- you manage schema via code migrations (knex, prisma, etc.)
- you need cross-platform support (supabase, neon, gcp, azure)
- you're comfortable with manual version management
- you want fewer dependencies

for most node.js projects with migration-based schema management, **raw sql is sufficient**.

### architecture

```
┌─────────────────────────────────────────────────────────┐
│                    postgresql                            │
├─────────────────────────────────────────────────────────┤
│  CREATE EXTENSION iso_price                              │
│         │                                                │
│         ▼                                                │
│  ┌─────────────────┐    ┌─────────────────────────────┐ │
│  │   pg_tle (C)    │───▶│  pgtle.feature_info table   │ │
│  │   hooks into    │    │  (stores extension sql)     │ │
│  │   extension     │    └─────────────────────────────┘ │
│  │   loader        │                                    │
│  └─────────────────┘                                    │
└─────────────────────────────────────────────────────────┘
```

---

## publisher workflow

### 1. generate pgtle sql artifact

wrap the extension sql in `pgtle.install_extension()`:

```sql
-- iso_price--1.0.0.pgtle.sql
SELECT pgtle.install_extension(
  'iso_price',                    -- extension name
  '1.0.0',                        -- version
  'ISO-compliant price types: iso_price_shape for arithmetic, iso_price_words for human-readable storage',
  $_pgtle_$
    -- types
    CREATE TYPE iso_price_shape AS (
      amount BIGINT,
      currency CHAR(3),
      exponent SMALLINT
    );

    CREATE DOMAIN iso_price_words AS TEXT
      CHECK (VALUE ~ '^[A-Z]{3} -?[0-9]+(\.[0-9]+)?$');

    -- functions
    CREATE FUNCTION iso_price_shape(
      amount BIGINT,
      currency CHAR(3),
      exponent SMALLINT DEFAULT 2
    ) RETURNS iso_price_shape AS $$
      SELECT ROW(amount, UPPER(currency), exponent)::iso_price_shape;
    $$ LANGUAGE SQL IMMUTABLE STRICT;

    -- ... all other functions, operators, aggregates ...
  $_pgtle_$
);
```

### 2. distribute via github/npm

the `.pgtle.sql` file is distributed alongside the raw sql:

```
dist/
  postgres/
    iso_price.init.sql           # raw sql (all platforms)
    iso_price--1.0.0.pgtle.sql   # pg_tle wrapped (aws)
```

### 3. version upgrades

for new versions, create additional registration:

```sql
-- iso_price--1.1.0.pgtle.sql
SELECT pgtle.install_update_path(
  'iso_price',
  '1.0.0',
  '1.1.0',
  $_pgtle_$
    -- migration sql: add new function
    CREATE FUNCTION iso_price_shape_abs(p iso_price_shape) ...;
  $_pgtle_$
);
```

---

## consumer workflow

### prerequisites

pg_tle must be enabled on the database instance:

| platform | pg_tle availability |
|----------|---------------------|
| aws rds postgres 14.5+ | ✅ available |
| aws aurora postgres 14.6+ | ✅ available |
| self-hosted postgres | ✅ install from source |
| supabase | ❌ not available |
| neon | ❌ not available |
| google cloud sql | ❌ not available |
| azure postgres | ❌ not available |

### installation steps

```sql
-- 1. enable pg_tle extension (one-time, requires rds_superuser)
CREATE EXTENSION IF NOT EXISTS pg_tle;

-- 2. grant pgtle_admin role to installer (if not rds_superuser)
GRANT pgtle_admin TO myuser;

-- 3. register the iso_price extension
-- (download iso_price--1.0.0.pgtle.sql from github/npm)
\i iso_price--1.0.0.pgtle.sql

-- 4. create the extension (standard postgres syntax!)
CREATE EXTENSION iso_price;

-- 5. verify
SELECT iso_price_shape(5037, 'USD', 2);
-- → (5037,USD,2)

\dx iso_price
-- → iso_price | 1.0.0 | public | ISO-compliant price types...
```

### upgrade steps

```sql
-- 1. register the new version
\i iso_price--1.1.0.pgtle.sql

-- 2. upgrade (standard postgres syntax!)
ALTER EXTENSION iso_price UPDATE TO '1.1.0';

-- 3. verify
\dx iso_price
-- → iso_price | 1.1.0 | public | ...
```

### uninstall steps

```sql
-- 1. drop the extension
DROP EXTENSION iso_price;

-- 2. unregister from pg_tle
SELECT pgtle.uninstall_extension('iso_price');
```

---

## pgtle api reference

### pgtle.install_extension

registers a new extension version.

```sql
pgtle.install_extension(
  name text,           -- extension name
  version text,        -- semver version
  description text,    -- shown in \dx
  ext text,            -- sql definitions
  requires text[]      -- dependencies (optional)
) RETURNS text
```

### pgtle.install_update_path

registers an upgrade path between versions.

```sql
pgtle.install_update_path(
  name text,           -- extension name
  from_version text,   -- source version
  to_version text,     -- target version
  ext text             -- migration sql
) RETURNS boolean
```

### pgtle.uninstall_extension

removes extension registration.

```sql
pgtle.uninstall_extension(
  name text,
  version text DEFAULT NULL  -- NULL = all versions
) RETURNS boolean
```

### pgtle.available_extensions

view of registered extensions.

```sql
SELECT * FROM pgtle.available_extensions();
-- name      | default_version | comment
-- iso_price | 1.0.0           | ISO-compliant price types...
```

---

## security considerations

### pgtle_admin role

the `pgtle_admin` role is created when pg_tle is installed. only members can register extensions.

```sql
-- grant to specific user
GRANT pgtle_admin TO extension_maintainer;

-- revoke after registration
REVOKE pgtle_admin FROM extension_maintainer;
```

### trusted languages only

pg_tle only supports "trusted" languages that cannot access the filesystem:

- ✅ sql
- ✅ plpgsql
- ✅ plv8 (javascript)
- ✅ plperl (perl)
- ❌ plpythonu (untrusted)
- ❌ C extensions

iso_price uses only sql + plpgsql, so it is fully compatible.

---

## build automation

### generate pgtle sql from raw sql

```ts
// build/generatePgtleSql.ts
import { readFileSync, writeFileSync } from 'fs';

const rawSql = readFileSync('dist/postgres/iso_price.init.sql', 'utf-8');
const version = require('../package.json').version;

const pgtleSql = `
SELECT pgtle.install_extension(
  'iso_price',
  '${version}',
  'ISO-compliant price types: iso_price_shape for arithmetic, iso_price_words for human-readable storage',
  \$_pgtle_\$
${rawSql}
  \$_pgtle_\$
);
`;

writeFileSync(`dist/postgres/iso_price--${version}.pgtle.sql`, pgtleSql);
```

---

## sources

- [aws: pg_tle overview](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL_trusted_language_extension.overview.html)
- [aws: pgtle.install_extension](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/pgtle.install_extension.html)
- [aws: TLE setup guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL_trusted_language_extension-setup.html)
- [github: aws/pg_tle](https://github.com/aws/pg_tle)
- [pganalyze: pg_tle tutorial](https://pganalyze.com/blog/5mins-postgres-pg-tle-custom-extensions-aws-rds-aurora-trusted-languages-hooks)
