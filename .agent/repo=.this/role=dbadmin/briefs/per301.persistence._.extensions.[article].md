# iso-price persistence: database extensions

why database extensions are the preferred approach for iso-price storage.

---

## tl;dr

extensions abstract away the domain complexity of price arithmetic, comparison, and aggregation ‚Äî so you don't have to.

| database | extension support | iso_price status |
|----------|-------------------|------------------|
| **postgresql** | ‚úÖ native + pg_tle | ‚úÖ available |
| **sqlite** | ‚ö†Ô∏è limited (loadable) | üìã planned |

‚Üí for postgres usage + installation, see [per302.extension](./per302.persistence.postgres.extension.[article].md)

---

## why extensions?

without an extension, **every application** that stores prices must correctly implement:

1. exponent normalization for arithmetic
2. custom comparison logic for mixed exponents
3. aggregation with auto-normalization
4. currency mismatch detection
5. index-compatible sort order
6. conversion between shape and words formats

this is error-prone, duplicative, and hard to test comprehensively.

**with an extension**, the database handles all of this:

```sql
-- without extension: manual normalization required for sum
SELECT SUM(
  amount * POWER(10, (SELECT MAX(exponent) FROM prices) - exponent)
) / POWER(10, (SELECT MAX(exponent) FROM prices))
FROM prices WHERE currency = 'USD';

-- with extension: sum() auto-normalizes
SELECT sum(price) FROM prices WHERE currency = 'USD';
```

---

## complexity catalog

every iso-price implementation must handle these concerns. extensions encapsulate them; manual implementations must address each explicitly.

### 1. exponent normalization

prices with different exponents cannot be directly compared or summed.

| price a | price b | naive sum | correct sum |
|---------|---------|-----------|-------------|
| `(5037, USD, 2)` = $50.37 | `(5, USD, 6)` = $0.000005 | 5042 ‚ùå | `(50370005, USD, 6)` ‚úÖ |

**rule**: normalize to highest exponent before arithmetic.

```sql
-- manual normalization
amount_a * POWER(10, max_exp - exp_a) + amount_b * POWER(10, max_exp - exp_b)
```

### 2. comparison across exponents

lexicographic or naive numeric comparison fails for mixed exponents.

| comparison | naive result | correct result |
|------------|--------------|----------------|
| `(100, USD, 2)` vs `(1, USD, 0)` | 100 > 1 ‚úÖ | $1.00 = $1.00 ‚úÖ |
| `(100, USD, 2)` vs `(2, USD, 0)` | 100 > 2 ‚ùå | $1.00 < $2.00 ‚úÖ |

**rule**: normalize both to same exponent, then compare amounts.

### 3. aggregation (sum, avg)

aggregate functions must normalize all values to a common exponent.

```sql
-- without extension: complex CTE required
WITH normalized AS (
  SELECT amount * POWER(10, target_exp - exponent) AS norm_amount
  FROM prices, (SELECT MAX(exponent) AS target_exp FROM prices) m
)
SELECT SUM(norm_amount) FROM normalized;

-- with extension
SELECT sum(price) FROM prices;
```

### 4. currency mismatch detection

arithmetic across currencies must fail explicitly, not silently produce garbage.

| operation | expected behavior |
|-----------|-------------------|
| `USD 10.00 + EUR 5.00` | ‚ùå error: currency mismatch |
| `USD 10.00 + USD 5.00` | ‚úÖ `USD 15.00` |

**rule**: operators must check currency equality and raise on mismatch.

### 5. index-compatible sort

btree indexes require a total order. for iso-price:

- same currency: order by normalized amount
- different currencies: order by currency code, then amount

```sql
-- extension provides operator class for btree
CREATE INDEX idx_price ON orders USING btree (price);

-- without extension: expression index with normalization
CREATE INDEX idx_price ON orders (
  currency,
  amount * POWER(10, 12 - exponent)  -- normalize to pico
);
```

### 6. words ‚Üî shape conversion

applications need both formats:
- **shape** for arithmetic and queries
- **words** for display, logs, and portability

```sql
-- extension provides cast functions
SELECT price::text FROM orders;              -- shape ‚Üí words
SELECT 'USD 50.37'::iso_price FROM dual;     -- words ‚Üí shape

-- without extension: manual functions required
SELECT currency || ' ' || (amount::numeric / POWER(10, exponent))::text;
```

### 7. display value computation

convert internal representation to human-readable decimal.

```sql
-- formula
display_value = amount / 10^exponent

-- examples
(5037, USD, 2)  ‚Üí 50.37
(5, USD, 6)     ‚Üí 0.000005
(1000, JPY, 0)  ‚Üí 1000
```

### 8. precision boundaries

| exponent | name | min representable | max representable (BIGINT) |
|----------|------|-------------------|---------------------------|
| 0 | whole | 1 | 9,223,372,036,854,775,807 |
| 2 | centi | 0.01 | 92,233,720,368,547,758.07 |
| 6 | micro | 0.000001 | 9,223,372,036,854.775807 |
| 9 | nano | 0.000000001 | 9,223,372,036.854775807 |
| 12 | pico | 0.000000000001 | 9,223,372.036854775807 |

**rule**: choose exponent based on precision needs; be aware of max value limits.

---

## extension support by database

### postgresql ‚úÖ

**status**: iso_price extension available

- **pg_tle**: trusted language extensions (aws rds, aurora, self-hosted)
- **raw sql**: works on all postgres (supabase, neon, cloud sql, azure)

features:
- `iso_price_shape` composite type with operators
- `iso_price_words` domain type with numeric comparison
- `+`, `-`, `*` with auto-normalization
- `<`, `>`, `=` with exponent-aware comparison
- `sum()` aggregate
- btree operator class for indexes
- cast functions between shape and words

‚Üí see [per302.extension](./per302.persistence.postgres.extension.[article].md)

### sqlite üìã planned

**status**: not yet implemented

sqlite supports loadable extensions in C.

approach:
- custom functions for arithmetic
- application-defined collation for sort
- virtual table for complex queries

limitations:
- extensions must be loaded at connection time
- no persistent custom types
- limited operator overload

---

## decision matrix

| concern | extension | manual implementation |
|---------|-----------|----------------------|
| exponent normalization | automatic | must implement |
| comparison operators | native `<`, `>`, `=` | functions or app-layer |
| aggregation | native `sum()` | complex CTEs |
| currency mismatch | error on operator | must check explicitly |
| index support | btree operator class | expression indexes |
| type safety | database-enforced | app-layer validation |
| code duplication | zero | every app reimplements |

**recommendation**: use extensions when available. the complexity cost of manual implementation is high and error-prone.

---

## sources

- [per103.sql](./per103.persistence.primitives.sql.[article].md) ‚Äî manual sql patterns
- [per302.extension](./per302.persistence.postgres.extension.[article].md) ‚Äî postgres usage + installation
- [per303.implementation](./per303.persistence.postgres.extension.implementation.[guide].md) ‚Äî implementation reference
