# iso-price primitives: nosql databases

how to persist iso-price in nosql databases (dynamodb, mongodb, redis, s3, etc.).

---

## tl;dr

| approach | representation | best for |
|----------|----------------|----------|
| **words** (string) | `"USD 50.37"` | simplicity, human-readable, maximum portability |
| **shape** (object) | `{ amount: 5037, currency: "USD", exponent: 2 }` | app-layer arithmetic, type safety |

**recommendation**: use words (string) for nosql — simpler, portable, and nosql lacks the arithmetic operators that make shape worthwhile.

---

## IsoPriceWords (recommended)

store as a single string attribute.

### dynamodb

```json
{
  "pk": "INVOICE#123",
  "sk": "LINEITEM#1",
  "description": "widget purchase",
  "price": "USD 50.37"
}
```

```ts
// put item
await dynamodb.put({
  TableName: 'invoices',
  Item: {
    pk: 'INVOICE#123',
    sk: 'LINEITEM#1',
    description: 'widget purchase',
    price: 'USD 50.37',
  },
});

// get and parse
const item = await dynamodb.get({ ... });
const [currency, value] = item.price.split(' ');
const numericValue = parseFloat(value);
```

### mongodb

```json
{
  "_id": "invoice-123-line-1",
  "description": "widget purchase",
  "price": "USD 50.37"
}
```

```ts
// insert
await collection.insertOne({
  description: 'widget purchase',
  price: 'USD 50.37',
});

// query (string comparison, not numeric!)
const items = await collection.find({
  price: { $regex: /^USD / }  // find all USD prices
});
```

### redis

```sh
# store as string
SET invoice:123:line:1:price "USD 50.37"

# store as hash field
HSET invoice:123:line:1 price "USD 50.37"
```

### s3 / json files

```json
{
  "invoiceId": "123",
  "lineItems": [
    { "description": "widget", "price": "USD 50.37" },
    { "description": "api tokens", "price": "USD 0.000005" }
  ]
}
```

### pros

- **simple** — one attribute
- **portable** — works in any nosql store
- **human-readable** — clear in logs, exports, debug
- **schema-free** — no type definitions needed
- **copy-paste safe** — easy to move between systems

### cons

- **no native arithmetic** — must parse in app layer
- **no numeric sort** — lexicographic order is wrong
- **no range queries** — can't do `price > "USD 10"` correctly

---

## IsoPriceShape

store as nested object for type safety.

### dynamodb

```json
{
  "pk": "INVOICE#123",
  "sk": "LINEITEM#1",
  "description": "widget purchase",
  "price": {
    "amount": 5037,
    "currency": "USD",
    "exponent": 2
  }
}
```

```ts
// put item
await dynamodb.put({
  TableName: 'invoices',
  Item: {
    pk: 'INVOICE#123',
    sk: 'LINEITEM#1',
    description: 'widget purchase',
    price: {
      amount: 5037,
      currency: 'USD',
      exponent: 2,
    },
  },
});

// get and use directly
const item = await dynamodb.get({ ... });
const displayValue = item.price.amount / Math.pow(10, item.price.exponent);
```

### mongodb

```json
{
  "_id": "invoice-123-line-1",
  "description": "widget purchase",
  "price": {
    "amount": 5037,
    "currency": "USD",
    "exponent": 2
  }
}
```

```ts
// query by currency
const usdItems = await collection.find({
  'price.currency': 'USD'
});

// query by amount (same exponent only!)
const highValue = await collection.find({
  'price.currency': 'USD',
  'price.exponent': 2,
  'price.amount': { $gt: 10000 }  // > $100.00
});
```

### pros

- **type-safe** — explicit structure
- **queryable** — filter by currency, exponent (mongodb)
- **no parse step** — fields are already separated
- **arithmetic ready** — integer amount available directly

### cons

- **more bytes** — nested object overhead
- **mixed exponent queries** — can't compare amounts with different exponents
- **dynamodb limitations** — no native nested object queries
- **complexity** — more attributes to manage

---

## conversion in app layer

both approaches require app-layer conversion for arithmetic.

```ts
// words → shape
const fromWords = (words: string): IsoPriceShape => {
  const [currency, valueStr] = words.split(' ');
  const decimalPlaces = (valueStr.split('.')[1] || '').length;
  const amount = BigInt(Math.round(parseFloat(valueStr) * Math.pow(10, decimalPlaces)));
  return { amount, currency, exponent: decimalPlaces };
};

// shape → words
const toWords = (shape: IsoPriceShape): string => {
  const displayValue = Number(shape.amount) / Math.pow(10, shape.exponent);
  return `${shape.currency} ${displayValue}`;
};

// shape → display
const toDisplay = (shape: IsoPriceShape): number => {
  return Number(shape.amount) / Math.pow(10, shape.exponent);
};
```

---

## recommendation

**use IsoPriceWords (string)** for nosql:

1. nosql lacks arithmetic operators — shape's structure provides no benefit
2. simpler to store and retrieve
3. human-readable in logs and debug
4. maximum portability across nosql platforms

**use IsoPriceShape (object)** only when:
- mongodb and you need to query by currency frequently
- your app layer already works with shape objects
- type safety in storage is a requirement

---

## comparison with sql

| feature | sql + shape | nosql + words |
|---------|-------------|---------------|
| native arithmetic | ✅ | ❌ |
| numeric sort | ✅ | ❌ |
| query by currency | ✅ | ⚠️ (string match) |
| schema enforcement | ✅ | ❌ |
| human-readable | ⚠️ | ✅ |
| portability | ⚠️ | ✅ |

for numeric operations, consider sql databases or compute in app layer.
