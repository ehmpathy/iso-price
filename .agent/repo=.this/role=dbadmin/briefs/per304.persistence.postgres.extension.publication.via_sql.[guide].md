# iso_price sql implementation

the canonical, idempotent sql for the iso_price extension.

→ for usage guide, see [per302.extension](./per302.persistence.postgres.extension.[article].md)
→ for publication overview, see [per304.overview](./per304.persistence.postgres.extension.publication._.[overview].md)

---

## tl;dr

this file contains the full idempotent sql. run it to install or upgrade:

```sh
psql -h your-host -U your-user -d your-database -f iso_price.init.sql
```

**idempotent** = safe to run multiple times. upgrades just re-run the same sql.

---

## design

| object | idempotent pattern |
|--------|-------------------|
| types/domains | `DO $$ BEGIN CREATE ... EXCEPTION WHEN duplicate_object THEN NULL; END $$;` |
| functions | `CREATE OR REPLACE FUNCTION` |
| operators | `DROP OPERATOR IF EXISTS` + `CREATE OPERATOR` |
| aggregates | `DROP AGGREGATE IF EXISTS` + `CREATE AGGREGATE` |
| operator classes | `DROP OPERATOR CLASS IF EXISTS` + `CREATE OPERATOR CLASS` |

**limitation**: type/domain structure cannot be altered once tables use them. new functions/operators are safe to add; composite type field changes require migration.

---

## install sql

save as `iso_price.init.sql`:

```sql
-- ============================================================================
-- iso_price postgresql extension
-- idempotent sql - safe to run multiple times for install or upgrade
-- ============================================================================

-- ============================================================================
-- types
-- ============================================================================

-- iso_price_shape: composite type for structured price storage
DO $$ BEGIN
  CREATE TYPE iso_price_shape AS (
    amount BIGINT,        -- integer in minor units
    currency CHAR(3),     -- iso 4217 currency code
    exponent SMALLINT     -- decimal places (2=cents, 6=micro, 9=nano, 12=pico)
  );
  COMMENT ON TYPE iso_price_shape IS 'ISO-compliant price: integer amount + currency + exponent';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- iso_price_words: domain for human-readable price format (numeric separator notation)
DO $$ BEGIN
  CREATE DOMAIN iso_price_words AS TEXT
    CHECK (VALUE ~ '^[A-Z]{3} -?[0-9_]+(\.[0-9_]+)?$');
  COMMENT ON DOMAIN iso_price_words IS 'ISO-compliant price in prefix-code format with underscore separators: {currency} {display_value}';
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- ============================================================================
-- iso_price_shape functions
-- ============================================================================

-- constructor
CREATE OR REPLACE FUNCTION iso_price_shape(
  amount BIGINT,
  currency CHAR(3),
  exponent SMALLINT DEFAULT 2
) RETURNS iso_price_shape AS $$
  SELECT ROW(amount, UPPER(currency), exponent)::iso_price_shape;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- display value as numeric
CREATE OR REPLACE FUNCTION iso_price_shape_display(p iso_price_shape)
RETURNS NUMERIC AS $$
  SELECT (p).amount::NUMERIC / POWER(10, (p).exponent);
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- normalize to target exponent
CREATE OR REPLACE FUNCTION iso_price_shape_normalize(p iso_price_shape, target_exponent SMALLINT)
RETURNS iso_price_shape AS $$
  SELECT CASE
    WHEN (p).exponent = target_exponent THEN p
    WHEN (p).exponent < target_exponent THEN
      ROW(
        (p).amount * POWER(10, target_exponent - (p).exponent)::BIGINT,
        (p).currency,
        target_exponent
      )::iso_price_shape
    ELSE
      ROW(
        (p).amount / POWER(10, (p).exponent - target_exponent)::BIGINT,
        (p).currency,
        target_exponent
      )::iso_price_shape
  END;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- add two prices (auto-normalizes to most granular exponent)
CREATE OR REPLACE FUNCTION iso_price_shape_add(a iso_price_shape, b iso_price_shape)
RETURNS iso_price_shape AS $$
DECLARE
  target_exp SMALLINT;
  a_norm BIGINT;
  b_norm BIGINT;
BEGIN
  IF (a).currency != (b).currency THEN
    RAISE EXCEPTION 'iso_price_shape_add: currency mismatch (% vs %)', (a).currency, (b).currency;
  END IF;

  target_exp := GREATEST((a).exponent, (b).exponent);
  a_norm := (a).amount * POWER(10, target_exp - (a).exponent)::BIGINT;
  b_norm := (b).amount * POWER(10, target_exp - (b).exponent)::BIGINT;

  RETURN ROW(a_norm + b_norm, (a).currency, target_exp)::iso_price_shape;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- subtract two prices
CREATE OR REPLACE FUNCTION iso_price_shape_subtract(a iso_price_shape, b iso_price_shape)
RETURNS iso_price_shape AS $$
DECLARE
  target_exp SMALLINT;
  a_norm BIGINT;
  b_norm BIGINT;
BEGIN
  IF (a).currency != (b).currency THEN
    RAISE EXCEPTION 'iso_price_shape_subtract: currency mismatch (% vs %)', (a).currency, (b).currency;
  END IF;

  target_exp := GREATEST((a).exponent, (b).exponent);
  a_norm := (a).amount * POWER(10, target_exp - (a).exponent)::BIGINT;
  b_norm := (b).amount * POWER(10, target_exp - (b).exponent)::BIGINT;

  RETURN ROW(a_norm - b_norm, (a).currency, target_exp)::iso_price_shape;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- negate a price
CREATE OR REPLACE FUNCTION iso_price_shape_negate(p iso_price_shape)
RETURNS iso_price_shape AS $$
  SELECT ROW(-(p).amount, (p).currency, (p).exponent)::iso_price_shape;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- multiply by integer scalar
CREATE OR REPLACE FUNCTION iso_price_shape_multiply(p iso_price_shape, scalar BIGINT)
RETURNS iso_price_shape AS $$
  SELECT ROW((p).amount * scalar, (p).currency, (p).exponent)::iso_price_shape;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- multiply by integer scalar (reversed args)
CREATE OR REPLACE FUNCTION iso_price_shape_multiply_rev(scalar BIGINT, p iso_price_shape)
RETURNS iso_price_shape AS $$
  SELECT ROW((p).amount * scalar, (p).currency, (p).exponent)::iso_price_shape;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- comparison
CREATE OR REPLACE FUNCTION iso_price_shape_cmp(a iso_price_shape, b iso_price_shape)
RETURNS INTEGER AS $$
DECLARE
  target_exp SMALLINT;
  a_norm BIGINT;
  b_norm BIGINT;
BEGIN
  IF (a).currency != (b).currency THEN
    RAISE EXCEPTION 'iso_price_shape_cmp: cannot compare different currencies (% vs %)', (a).currency, (b).currency;
  END IF;

  target_exp := GREATEST((a).exponent, (b).exponent);
  a_norm := (a).amount * POWER(10, target_exp - (a).exponent)::BIGINT;
  b_norm := (b).amount * POWER(10, target_exp - (b).exponent)::BIGINT;

  RETURN CASE
    WHEN a_norm < b_norm THEN -1
    WHEN a_norm > b_norm THEN 1
    ELSE 0
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_shape_eq(a iso_price_shape, b iso_price_shape) RETURNS BOOLEAN AS $$
  SELECT iso_price_shape_cmp(a, b) = 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_shape_ne(a iso_price_shape, b iso_price_shape) RETURNS BOOLEAN AS $$
  SELECT iso_price_shape_cmp(a, b) != 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_shape_lt(a iso_price_shape, b iso_price_shape) RETURNS BOOLEAN AS $$
  SELECT iso_price_shape_cmp(a, b) < 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_shape_le(a iso_price_shape, b iso_price_shape) RETURNS BOOLEAN AS $$
  SELECT iso_price_shape_cmp(a, b) <= 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_shape_gt(a iso_price_shape, b iso_price_shape) RETURNS BOOLEAN AS $$
  SELECT iso_price_shape_cmp(a, b) > 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_shape_ge(a iso_price_shape, b iso_price_shape) RETURNS BOOLEAN AS $$
  SELECT iso_price_shape_cmp(a, b) >= 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- aggregate state function
CREATE OR REPLACE FUNCTION iso_price_shape_sum_sfunc(state iso_price_shape, val iso_price_shape)
RETURNS iso_price_shape AS $$
BEGIN
  IF state IS NULL THEN RETURN val; END IF;
  IF val IS NULL THEN RETURN state; END IF;
  RETURN iso_price_shape_add(state, val);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- iso_price_words functions
-- ============================================================================

-- extract currency code
CREATE OR REPLACE FUNCTION iso_price_words_currency(p iso_price_words)
RETURNS CHAR(3) AS $$
  SELECT split_part(p, ' ', 1)::CHAR(3);
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- extract numeric value (strips underscore separators)
CREATE OR REPLACE FUNCTION iso_price_words_value(p iso_price_words)
RETURNS NUMERIC AS $$
  SELECT REPLACE(split_part(p, ' ', 2), '_', '')::NUMERIC;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- comparison (strips underscore separators)
CREATE OR REPLACE FUNCTION iso_price_words_cmp(a iso_price_words, b iso_price_words)
RETURNS INTEGER AS $$
DECLARE
  a_currency CHAR(3);
  b_currency CHAR(3);
  a_value NUMERIC;
  b_value NUMERIC;
BEGIN
  a_currency := split_part(a, ' ', 1);
  b_currency := split_part(b, ' ', 1);

  IF a_currency != b_currency THEN
    RAISE EXCEPTION 'iso_price_words_cmp: cannot compare different currencies (% vs %)', a_currency, b_currency;
  END IF;

  a_value := REPLACE(split_part(a, ' ', 2), '_', '')::NUMERIC;
  b_value := REPLACE(split_part(b, ' ', 2), '_', '')::NUMERIC;

  RETURN CASE
    WHEN a_value < b_value THEN -1
    WHEN a_value > b_value THEN 1
    ELSE 0
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_words_eq(a iso_price_words, b iso_price_words) RETURNS BOOLEAN AS $$
  SELECT iso_price_words_cmp(a, b) = 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_words_ne(a iso_price_words, b iso_price_words) RETURNS BOOLEAN AS $$
  SELECT iso_price_words_cmp(a, b) != 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_words_lt(a iso_price_words, b iso_price_words) RETURNS BOOLEAN AS $$
  SELECT iso_price_words_cmp(a, b) < 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_words_le(a iso_price_words, b iso_price_words) RETURNS BOOLEAN AS $$
  SELECT iso_price_words_cmp(a, b) <= 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_words_gt(a iso_price_words, b iso_price_words) RETURNS BOOLEAN AS $$
  SELECT iso_price_words_cmp(a, b) > 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION iso_price_words_ge(a iso_price_words, b iso_price_words) RETURNS BOOLEAN AS $$
  SELECT iso_price_words_cmp(a, b) >= 0;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- ============================================================================
-- conversion functions
-- ============================================================================

-- shape to words
CREATE OR REPLACE FUNCTION iso_price_shape_to_words(p iso_price_shape)
RETURNS iso_price_words AS $$
  SELECT ((p).currency || ' ' || ((p).amount::NUMERIC / POWER(10, (p).exponent))::TEXT)::iso_price_words;
$$ LANGUAGE SQL IMMUTABLE STRICT;

-- words to shape (infers exponent from decimal places, strips underscore separators)
CREATE OR REPLACE FUNCTION iso_price_words_to_shape(words iso_price_words)
RETURNS iso_price_shape AS $$
DECLARE
  parts TEXT[];
  currency CHAR(3);
  value_str TEXT;
  value_clean TEXT;
  decimal_places INT;
  amount BIGINT;
BEGIN
  parts := string_to_array(words::TEXT, ' ');
  currency := parts[1];
  value_str := parts[2];

  -- strip underscore separators before conversion
  value_clean := REPLACE(value_str, '_', '');

  -- count decimal places (from cleaned value)
  IF position('.' in value_clean) > 0 THEN
    decimal_places := length(split_part(value_clean, '.', 2));
  ELSE
    decimal_places := 0;
  END IF;

  -- convert to integer amount
  amount := (value_clean::NUMERIC * POWER(10, decimal_places))::BIGINT;

  RETURN ROW(amount, currency, decimal_places::SMALLINT)::iso_price_shape;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- ============================================================================
-- iso_price_shape operators (drop + create for idempotency)
-- ============================================================================

DROP OPERATOR IF EXISTS + (iso_price_shape, iso_price_shape);
CREATE OPERATOR + (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_add,
  COMMUTATOR = +
);

DROP OPERATOR IF EXISTS - (iso_price_shape, iso_price_shape);
CREATE OPERATOR - (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_subtract
);

DROP OPERATOR IF EXISTS - (NONE, iso_price_shape);
CREATE OPERATOR - (
  RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_negate
);

DROP OPERATOR IF EXISTS * (iso_price_shape, BIGINT);
CREATE OPERATOR * (
  LEFTARG = iso_price_shape, RIGHTARG = BIGINT,
  FUNCTION = iso_price_shape_multiply
);

DROP OPERATOR IF EXISTS * (BIGINT, iso_price_shape);
CREATE OPERATOR * (
  LEFTARG = BIGINT, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_multiply_rev,
  COMMUTATOR = *
);

DROP OPERATOR IF EXISTS = (iso_price_shape, iso_price_shape);
CREATE OPERATOR = (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_eq,
  COMMUTATOR = =, NEGATOR = <>,
  RESTRICT = eqsel, JOIN = eqjoinsel,
  HASHES, MERGES
);

DROP OPERATOR IF EXISTS <> (iso_price_shape, iso_price_shape);
CREATE OPERATOR <> (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_ne,
  COMMUTATOR = <>, NEGATOR = =,
  RESTRICT = neqsel, JOIN = neqjoinsel
);

DROP OPERATOR IF EXISTS < (iso_price_shape, iso_price_shape);
CREATE OPERATOR < (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_lt,
  COMMUTATOR = >, NEGATOR = >=,
  RESTRICT = scalarltsel, JOIN = scalarltjoinsel
);

DROP OPERATOR IF EXISTS <= (iso_price_shape, iso_price_shape);
CREATE OPERATOR <= (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_le,
  COMMUTATOR = >=, NEGATOR = >,
  RESTRICT = scalarlesel, JOIN = scalarlejoinsel
);

DROP OPERATOR IF EXISTS > (iso_price_shape, iso_price_shape);
CREATE OPERATOR > (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_gt,
  COMMUTATOR = <, NEGATOR = <=,
  RESTRICT = scalargtsel, JOIN = scalargtjoinsel
);

DROP OPERATOR IF EXISTS >= (iso_price_shape, iso_price_shape);
CREATE OPERATOR >= (
  LEFTARG = iso_price_shape, RIGHTARG = iso_price_shape,
  FUNCTION = iso_price_shape_ge,
  COMMUTATOR = <=, NEGATOR = <,
  RESTRICT = scalargesel, JOIN = scalargejoinsel
);

-- ============================================================================
-- iso_price_words operators (drop + create for idempotency)
-- ============================================================================

DROP OPERATOR IF EXISTS = (iso_price_words, iso_price_words);
CREATE OPERATOR = (
  LEFTARG = iso_price_words, RIGHTARG = iso_price_words,
  FUNCTION = iso_price_words_eq,
  COMMUTATOR = =, NEGATOR = <>,
  RESTRICT = eqsel, JOIN = eqjoinsel,
  HASHES, MERGES
);

DROP OPERATOR IF EXISTS <> (iso_price_words, iso_price_words);
CREATE OPERATOR <> (
  LEFTARG = iso_price_words, RIGHTARG = iso_price_words,
  FUNCTION = iso_price_words_ne,
  COMMUTATOR = <>, NEGATOR = =,
  RESTRICT = neqsel, JOIN = neqjoinsel
);

DROP OPERATOR IF EXISTS < (iso_price_words, iso_price_words);
CREATE OPERATOR < (
  LEFTARG = iso_price_words, RIGHTARG = iso_price_words,
  FUNCTION = iso_price_words_lt,
  COMMUTATOR = >, NEGATOR = >=,
  RESTRICT = scalarltsel, JOIN = scalarltjoinsel
);

DROP OPERATOR IF EXISTS <= (iso_price_words, iso_price_words);
CREATE OPERATOR <= (
  LEFTARG = iso_price_words, RIGHTARG = iso_price_words,
  FUNCTION = iso_price_words_le,
  COMMUTATOR = >=, NEGATOR = >,
  RESTRICT = scalarlesel, JOIN = scalarlejoinsel
);

DROP OPERATOR IF EXISTS > (iso_price_words, iso_price_words);
CREATE OPERATOR > (
  LEFTARG = iso_price_words, RIGHTARG = iso_price_words,
  FUNCTION = iso_price_words_gt,
  COMMUTATOR = <, NEGATOR = <=,
  RESTRICT = scalargtsel, JOIN = scalargtjoinsel
);

DROP OPERATOR IF EXISTS >= (iso_price_words, iso_price_words);
CREATE OPERATOR >= (
  LEFTARG = iso_price_words, RIGHTARG = iso_price_words,
  FUNCTION = iso_price_words_ge,
  COMMUTATOR = <=, NEGATOR = <,
  RESTRICT = scalargesel, JOIN = scalargejoinsel
);

-- ============================================================================
-- operator classes (drop + create for idempotency)
-- ============================================================================

DROP OPERATOR CLASS IF EXISTS iso_price_shape_ops USING btree;
CREATE OPERATOR CLASS iso_price_shape_ops
DEFAULT FOR TYPE iso_price_shape USING btree AS
  OPERATOR 1 <,
  OPERATOR 2 <=,
  OPERATOR 3 =,
  OPERATOR 4 >=,
  OPERATOR 5 >,
  FUNCTION 1 iso_price_shape_cmp(iso_price_shape, iso_price_shape);

DROP OPERATOR CLASS IF EXISTS iso_price_words_ops USING btree;
CREATE OPERATOR CLASS iso_price_words_ops
DEFAULT FOR TYPE iso_price_words USING btree AS
  OPERATOR 1 <,
  OPERATOR 2 <=,
  OPERATOR 3 =,
  OPERATOR 4 >=,
  OPERATOR 5 >,
  FUNCTION 1 iso_price_words_cmp(iso_price_words, iso_price_words);

-- ============================================================================
-- aggregates (drop + create for idempotency)
-- ============================================================================

DROP AGGREGATE IF EXISTS iso_price_shape_sum(iso_price_shape);
CREATE AGGREGATE iso_price_shape_sum(iso_price_shape) (
  SFUNC = iso_price_shape_sum_sfunc,
  STYPE = iso_price_shape
);

DROP AGGREGATE IF EXISTS sum(iso_price_shape);
CREATE AGGREGATE sum(iso_price_shape) (
  SFUNC = iso_price_shape_sum_sfunc,
  STYPE = iso_price_shape
);
```

---

## uninstall

save as `iso_price.drop.sql` to remove all iso_price objects:

```sql
-- aggregates
DROP AGGREGATE IF EXISTS sum(iso_price_shape);
DROP AGGREGATE IF EXISTS iso_price_shape_sum(iso_price_shape);

-- operator classes
DROP OPERATOR CLASS IF EXISTS iso_price_words_ops USING btree;
DROP OPERATOR CLASS IF EXISTS iso_price_shape_ops USING btree;

-- iso_price_words operators
DROP OPERATOR IF EXISTS >= (iso_price_words, iso_price_words);
DROP OPERATOR IF EXISTS > (iso_price_words, iso_price_words);
DROP OPERATOR IF EXISTS <= (iso_price_words, iso_price_words);
DROP OPERATOR IF EXISTS < (iso_price_words, iso_price_words);
DROP OPERATOR IF EXISTS <> (iso_price_words, iso_price_words);
DROP OPERATOR IF EXISTS = (iso_price_words, iso_price_words);

-- iso_price_shape operators
DROP OPERATOR IF EXISTS >= (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS > (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS <= (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS < (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS <> (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS = (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS * (BIGINT, iso_price_shape);
DROP OPERATOR IF EXISTS * (iso_price_shape, BIGINT);
DROP OPERATOR IF EXISTS - (NONE, iso_price_shape);
DROP OPERATOR IF EXISTS - (iso_price_shape, iso_price_shape);
DROP OPERATOR IF EXISTS + (iso_price_shape, iso_price_shape);

-- conversion functions
DROP FUNCTION IF EXISTS iso_price_words_to_shape(iso_price_words);
DROP FUNCTION IF EXISTS iso_price_shape_to_words(iso_price_shape);

-- iso_price_words functions
DROP FUNCTION IF EXISTS iso_price_words_ge(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_gt(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_le(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_lt(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_ne(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_eq(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_cmp(iso_price_words, iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_value(iso_price_words);
DROP FUNCTION IF EXISTS iso_price_words_currency(iso_price_words);

-- iso_price_shape functions
DROP FUNCTION IF EXISTS iso_price_shape_sum_sfunc(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_ge(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_gt(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_le(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_lt(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_ne(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_eq(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_cmp(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_multiply_rev(BIGINT, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_multiply(iso_price_shape, BIGINT);
DROP FUNCTION IF EXISTS iso_price_shape_negate(iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_subtract(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_add(iso_price_shape, iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape_normalize(iso_price_shape, SMALLINT);
DROP FUNCTION IF EXISTS iso_price_shape_display(iso_price_shape);
DROP FUNCTION IF EXISTS iso_price_shape(BIGINT, CHAR, SMALLINT);

-- types
DROP DOMAIN IF EXISTS iso_price_words;
DROP TYPE IF EXISTS iso_price_shape;
```

---

## sources

- [postgresql: composite types](https://www.postgresql.org/docs/current/rowtypes.html)
- [postgresql: create domain](https://www.postgresql.org/docs/current/sql-createdomain.html)
- [postgresql: user-defined aggregates](https://www.postgresql.org/docs/current/xaggr.html)
- [postgresql: operator classes](https://www.postgresql.org/docs/current/indexes-opclass.html)
