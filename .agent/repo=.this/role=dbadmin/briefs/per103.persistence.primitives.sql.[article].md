# iso-price primitives: sql databases

how to persist iso-price in sql databases (postgres, mysql, sqlite, etc.) without custom extensions.

---

## ⚠️ recommendation: use postgres + iso_price extension

the optimal storage pattern (`BIGINT, CHAR(3), SMALLINT`) requires **domain math** for correct behavior:
- exponent normalization before arithmetic
- custom comparison operators for mixed-exponent values
- aggregate functions that auto-normalize

**if you use postgres**, the `iso_price` extension handles all this for you:
- native `+`, `-`, `*` operators with auto-normalization
- correct `<`, `>`, `=` comparison across exponents
- `sum()` aggregate that normalizes automatically
- btree index support

→ see [per302.extension](./per302.persistence.postgres.extension.[article].md) for installation

**if you must use mysql/sqlite** (or postgres without extension), this guide covers the manual approach — but be aware you'll need to implement normalization logic in your application layer.

---

## tl;dr

| approach               | schema                          | best for                                |
| ---------------------- | ------------------------------- | --------------------------------------- |
| **normalized table** ⭐ | `iso_price` table + foreign key | arithmetic, queries, dedup, consistency |
| **words** (1 column)   | `price TEXT`                    | simplicity, portability, read-only      |

**recommendation**: use normalized `iso_price` table for most cases — centralizes price logic and enables deduplication.

---

## normalized table pattern (recommended)

rather than inline iso-price columns on each entity table, normalize into a dedicated `iso_price` table and reference via foreign key.

### schema

```sql
-- dedicated iso_price table
CREATE TABLE iso_price (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  amount BIGINT NOT NULL,
  currency CHAR(3) NOT NULL,
  exponent SMALLINT NOT NULL,
  CONSTRAINT chk_exponent CHECK (exponent >= 0 AND exponent <= 12)
);

-- unique constraint for deduplication
CREATE UNIQUE INDEX idx_iso_price_unique
  ON iso_price(amount, currency, exponent);

-- entity references the price
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,
  price_id UUID NOT NULL REFERENCES iso_price(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### why normalize?

| benefit            | explanation                                                     |
| ------------------ | --------------------------------------------------------------- |
| **deduplication**  | identical prices share one row (e.g., many items at `USD 9.99`) |
| **consistency**    | price logic lives in one place, not scattered across tables     |
| **audit trail**    | easier to track price changes via price_id references           |
| **schema clarity** | entity tables stay focused on their domain                      |
| **reusability**    | same price can be referenced by multiple entities               |

### insert pattern

```sql
-- insert or find price (idempotent)
INSERT INTO iso_price (amount, currency, exponent)
VALUES (5037, 'USD', 2)
ON CONFLICT (amount, currency, exponent) DO NOTHING
RETURNING id;

-- if no id returned, find it
SELECT id FROM iso_price
WHERE amount = 5037 AND currency = 'USD' AND exponent = 2;

-- then reference from entity
INSERT INTO invoice_line_item (description, price_id)
VALUES ('widget purchase', :price_id);
```

### query with join

```sql
SELECT
  ili.description,
  p.amount,
  p.currency,
  p.exponent,
  p.amount / POWER(10, p.exponent) AS display_value
FROM invoice_line_item ili
JOIN iso_price p ON p.id = ili.price_id;
```

---

## IsoPriceWords

store as single text column for simplicity.

### schema

```sql
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,
  price TEXT NOT NULL,  -- "USD 50.37" format
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- optional: validate format
ALTER TABLE invoice_line_item
  ADD CONSTRAINT chk_price_format
  CHECK (price ~ '^[A-Z]{3} -?[0-9]+(\.[0-9]+)?$');
```

### insert

```sql
INSERT INTO invoice_line_item (description, price)
VALUES ('widget purchase', 'USD 50.37');

INSERT INTO invoice_line_item (description, price)
VALUES ('gpt-4o input tokens', 'USD 0.000005');
```

### query

```sql
-- extract currency (requires string parse)
SELECT
  description,
  split_part(price, ' ', 1) AS currency,
  split_part(price, ' ', 2)::NUMERIC AS value
FROM invoice_line_item;
```

### pros

- **simple schema** — one column
- **human-readable** — clear in logs, exports, debug
- **portable** — same format works in any sql database

### cons

- **no native arithmetic** — must parse to compute
- **lexicographic sort** — "USD 100" < "USD 99" (wrong order)
- **no partial queries** — can't index by currency without expression index
- **parse overhead** — every operation requires string manipulation

---

## recommendation

**use postgres + iso_price extension** when possible:
- handles all domain math automatically
- see [per302.extension](./per302.persistence.postgres.extension.[article].md)

**use normalized iso_price table** for most sql cases:
1. centralizes price logic in one place
2. deduplicates identical prices across entities
3. keeps entity tables focused on their domain
4. enables consistent price behavior across the system

**use IsoPriceWords** only when:
- maximum portability is required
- schema must stay simple for legacy reasons
- prices are read-only (no arithmetic needed)

---

## postgres-specific

for postgres with custom types, operators, and automatic normalization:

→ see [per302.extension](./per302.persistence.postgres.extension.[article].md)
