# iso-price database persistence

how to store IsoPrices with variable exponent in postgresql and other databases.

## summary

| pattern               | storage                            | pros                        | cons                    |
| --------------------- | ---------------------------------- | --------------------------- | ----------------------- |
| **bigint + exponent** | `amount BIGINT, exponent SMALLINT` | fast, precise, flexible     | requires app-layer math |
| **numeric**           | `amount NUMERIC(24,12)`            | native math, high precision | slower, fixed scale     |
| **composite type**    | `price iso_price`                  | domain semantics            | less portable           |
| **jsonb**             | `price JSONB`                      | schema-free                 | no type safety          |

---

## pattern 1: bigint + exponent columns

the recommended pattern for iso-price. stores amount as integer with explicit exponent.

### schema

```sql
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,

  -- iso-price fields
  amount BIGINT NOT NULL,           -- integer amount in minor units
  currency CHAR(3) NOT NULL,        -- ISO 4217 code
  exponent SMALLINT NOT NULL,       -- decimal places (2=cents, 6=micro, 9=nano)

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- index for currency filter
CREATE INDEX idx_line_item_currency ON invoice_line_item(currency);

-- constraint: exponent in valid range
ALTER TABLE invoice_line_item
  ADD CONSTRAINT chk_exponent CHECK (exponent >= 0 AND exponent <= 12);
```

### example data

```sql
-- standard e-commerce: $50.37 (exponent 2)
INSERT INTO invoice_line_item (description, amount, currency, exponent)
VALUES ('widget purchase', 5037, 'USD', 2);

-- llm token cost: $0.000005 (exponent 6)
INSERT INTO invoice_line_item (description, amount, currency, exponent)
VALUES ('gpt-4o input tokens', 5, 'USD', 6);

-- lambda invocation: $0.000000213 (exponent 9)
INSERT INTO invoice_line_item (description, amount, currency, exponent)
VALUES ('lambda gb-second', 213, 'USD', 9);
```

### query with display value

```sql
SELECT
  description,
  amount,
  exponent,
  currency,
  amount / POWER(10, exponent) AS display_value
FROM invoice_line_item;
```

### sum with normalization

to sum prices with different exponents, normalize to the highest exponent first:

```sql
WITH normalized AS (
  SELECT
    amount * POWER(10, (SELECT MAX(exponent) FROM invoice_line_item) - exponent) AS normalized_amount,
    (SELECT MAX(exponent) FROM invoice_line_item) AS target_exponent,
    currency
  FROM invoice_line_item
  WHERE currency = 'USD'
)
SELECT
  SUM(normalized_amount) AS total_amount,
  target_exponent,
  currency,
  SUM(normalized_amount) / POWER(10, target_exponent) AS total_display
FROM normalized
GROUP BY target_exponent, currency;
```

---

## pattern 2: numeric with fixed scale

use postgresql NUMERIC for built-in decimal arithmetic.

### schema

```sql
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,

  -- fixed precision: 24 total digits, 12 after decimal
  amount NUMERIC(24, 12) NOT NULL,
  currency CHAR(3) NOT NULL,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### tradeoffs

| aspect      | bigint + exponent  | numeric                           |
| ----------- | ------------------ | --------------------------------- |
| performance | 50-70% faster      | slower due to arbitrary precision |
| storage     | 8 bytes + 2 bytes  | variable (up to 24 bytes)         |
| precision   | explicit, variable | fixed at schema time              |
| arithmetic  | app layer          | native sql                        |
| flexibility | any exponent 0-12  | locked to scale defined           |

### when to use numeric

- legacy systems that expect decimal values
- simple usecases where all prices share the same precision
- when native sql aggregation is critical

---

## pattern 3: composite type

postgresql supports custom composite types for domain semantics.

### schema

```sql
-- define the composite type
CREATE TYPE iso_price AS (
  amount BIGINT,
  currency CHAR(3),
  exponent SMALLINT
);

-- use in table
CREATE TABLE invoice (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subtotal iso_price NOT NULL,
  tax iso_price NOT NULL,
  total iso_price NOT NULL
);
```

### insert

```sql
INSERT INTO invoice (subtotal, tax, total)
VALUES (
  ROW(5037, 'USD', 2)::iso_price,
  ROW(403, 'USD', 2)::iso_price,
  ROW(5440, 'USD', 2)::iso_price
);
```

### query

```sql
SELECT
  (subtotal).amount,
  (subtotal).currency,
  (subtotal).exponent
FROM invoice;
```

### tradeoffs

- cleaner domain model
- less portable across databases
- harder to index individual fields

---

## pattern 4: jsonb

for schema-free or polyglot environments.

### schema

```sql
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,
  price JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- gin index for json queries
CREATE INDEX idx_line_item_price ON invoice_line_item USING GIN (price);
```

### insert

```sql
INSERT INTO invoice_line_item (description, price)
VALUES (
  'api call',
  '{"amount": 5, "currency": "USD", "exponent": 6}'::jsonb
);
```

### query

```sql
SELECT
  description,
  (price->>'amount')::BIGINT AS amount,
  price->>'currency' AS currency,
  (price->>'exponent')::SMALLINT AS exponent
FROM invoice_line_item;
```

### tradeoffs

- maximum flexibility
- no compile-time type safety
- json extraction overhead

---

## multi-currency considerations

### separate exponent per currency

iso 4217 defines standard exponents per currency:
- USD, EUR, GBP: 2 (cents)
- JPY, KRW: 0 (no minor unit)
- BHD, KWD, OMR: 3 (fils)

for sub-cent usecases (api costs), override with higher exponent.

### currency table

```sql
CREATE TABLE currency (
  code CHAR(3) PRIMARY KEY,
  name TEXT NOT NULL,
  standard_exponent SMALLINT NOT NULL,  -- iso 4217 default
  symbol TEXT
);

INSERT INTO currency VALUES
  ('USD', 'US Dollar', 2, '$'),
  ('EUR', 'Euro', 2, '€'),
  ('JPY', 'Japanese Yen', 0, '¥'),
  ('BHD', 'Bahraini Dinar', 3, 'BD');
```

### validation

```sql
-- ensure exponent >= standard for the currency
ALTER TABLE invoice_line_item
  ADD CONSTRAINT chk_exponent_valid
  CHECK (
    exponent >= (SELECT standard_exponent FROM currency WHERE code = invoice_line_item.currency)
  );
```

---

## performance notes

### bigint vs numeric benchmark

from postgresql performance tests:
- BIGINT arithmetic: ~50-70% faster than NUMERIC
- BIGINT storage: 8 bytes fixed vs NUMERIC variable
- index performance: BIGINT indexes are more compact

### recommendation

use **bigint + exponent** pattern for iso-price:
1. explicit precision via exponent column
2. fast integer arithmetic
3. flexible for any precision level (cents to pico-dollars)
4. clear domain semantics

---

## sources

- [PostgreSQL NUMERIC Type](https://www.postgresql.org/docs/current/datatype-numeric.html)
- [Google Spanner Precision Numeric](https://cloud.google.com/spanner/docs/data-types#precision-numeric)
- [Adyen Currency Codes](https://docs.adyen.com/development-resources/currency-codes/)
- [commercetools Money Types](https://docs.commercetools.com/api/types)
- [PostgreSQL Composite Types](https://www.postgresql.org/docs/current/rowtypes.html)
