# iso-price primitives: shape vs words

two fundamental approaches to represent iso-price values in any database.

---

## tl;dr

| approach | representation | best for |
|----------|----------------|----------|
| **IsoPriceShape** | `{ amount: 5037, currency: 'USD', exponent: 2 }` | arithmetic, queries, type safety |
| **IsoPriceWords** | `"USD 50.37"` | portability, human-readable, nosql |

---

## IsoPriceShape

store the structured representation with separate fields.

### format

```
{
  amount: bigint,      // integer in minor units
  currency: string,    // ISO 4217 code
  exponent: number     // decimal places
}
```

### examples

```
{ amount: 5037, currency: 'USD', exponent: 2 }     // $50.37
{ amount: 5, currency: 'USD', exponent: 6 }        // $0.000005 (micro)
{ amount: 1000, currency: 'JPY', exponent: 0 }     // ¥1000
{ amount: 1234567, currency: 'BHD', exponent: 3 }  // 1234.567 BHD
```

### pros

- **arithmetic** — integer math preserves precision
- **queryable** — filter by currency, exponent, amount range
- **indexable** — efficient lookups on individual fields
- **type-safe** — schema enforces structure
- **precise** — explicit exponent, no parse ambiguity

### cons

- **schema complexity** — 3 fields vs 1
- **portability** — requires schema support for composite/multiple columns
- **verbosity** — more bytes in json/nosql contexts

### when to use

- sql databases with schema support
- need arithmetic operations
- query by currency or amount range
- type safety is a priority

---

## IsoPriceWords

store the human-readable string representation.

### format

```
{currency} {display_value}
```

### examples

```
"USD 50.37"       // $50.37
"USD 0.000005"    // $0.000005 (micro)
"JPY 1000"        // ¥1000
"BHD 1234.567"    // 1234.567 BHD
```

### pros

- **simple** — one field
- **portable** — works anywhere (postgres, mysql, sqlite, dynamodb, s3, etc.)
- **human-readable** — immediately clear in logs and exports
- **schema-free** — no migrations for format changes
- **copy-paste safe** — easy to move between systems

### cons

- **no native arithmetic** — must parse in app layer for math
- **parse overhead** — every read requires string parse
- **no partial queries** — can't easily filter by currency without string ops
- **exponent inference** — must infer from decimal places or currency default
- **lexicographic sort** — "USD 100" < "USD 99" without custom comparison

### when to use

- nosql / document stores (dynamodb, mongodb)
- portability across databases
- schema simplicity is priority
- prices are primarily for storage/display, not aggregation

---

## conversion

### shape → words

```ts
const toIsoPriceWords = (price: IsoPriceShape): string => {
  const displayValue = Number(price.amount) / Math.pow(10, price.exponent);
  return `${price.currency} ${displayValue}`;
};
```

### words → shape

```ts
const fromIsoPriceWords = (words: string): IsoPriceShape => {
  const [currency, valueStr] = words.split(' ');
  const decimalPlaces = (valueStr.split('.')[1] || '').length;
  const amount = BigInt(Math.round(parseFloat(valueStr) * Math.pow(10, decimalPlaces)));
  return { amount, currency, exponent: decimalPlaces };
};
```

---

## decision matrix

| need | shape | words |
|------|-------|-------|
| arithmetic | ✅ | ❌ |
| filter by currency | ✅ | ❌ |
| portable across dbs | ⚠️ | ✅ |
| simple schema | ❌ | ✅ |
| human-readable | ❌ | ✅ |
| large dataset perf | ✅ | ❌ |
| nosql / dynamodb | ❌ | ✅ |

---

## recommendation

**default to IsoPriceShape** when:
- you have schema support (sql, typed nosql)
- you need arithmetic or aggregation
- you query prices frequently

**use IsoPriceWords** when:
- portability across databases is required
- schema simplicity is paramount
- prices are primarily for storage/display
- you're in a nosql environment

---

## postgres-specific

for postgres with custom types, operators, and numeric comparison:

→ see [per302.extension](./per302.persistence.postgres.extension.[article].md)
