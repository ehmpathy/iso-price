# iso-price database persistence research

research on industry best practices for price persistence in postgresql.

---

## tl;dr

| approach | industry adoption | performance | iso-price fit |
|----------|------------------|-------------|---------------|
| **bigint (cents)** | stripe, square, most fintech | fastest | ✅ recommended |
| **numeric(p,s)** | legacy finance, gaap compliance | ~27% slower | ⚠️ ok for fixed precision |
| **fixeddecimal ext** | niche, 2ndquadrant | near-bigint | ⚠️ requires extension |
| **money type** | avoid | n/a | ❌ locale-dependent |
| **float/double** | never | n/a | ❌ precision errors |

**verdict**: bigint + exponent columns is the industry standard pattern. stripe, square, and most payment processors use it. no postgresql extension provides meaningful improvement over this pattern.

---

## the two contenders

### 1. bigint (minor units) — industry standard

store amounts as integers in the smallest currency unit.

```sql
-- stripe pattern: $50.37 = 5037 cents
amount BIGINT NOT NULL,
currency CHAR(3) NOT NULL
```

**who uses it:**
- stripe: "a positive integer in the smallest currency unit (e.g., 100 cents to charge $1.00)"
- square, adyen, commercetools
- most modern payment systems

**why:**
- cpu-native operations (fastest possible)
- exact arithmetic (no float errors)
- 8 bytes fixed storage
- works with all currencies via iso 4217 exponent

### 2. numeric(precision, scale) — legacy finance

store amounts as arbitrary-precision decimals.

```sql
-- gaap pattern: $50.37 with 4 decimal places
amount NUMERIC(19, 4) NOT NULL,
currency CHAR(3) NOT NULL
```

**who uses it:**
- legacy bank systems
- gaap-compliant account systems (requires 4+ decimal places)
- systems that need native sql aggregation

**why:**
- exact decimal arithmetic in sql
- no app-layer conversion needed
- gaap requires 4 decimal places minimum

---

## performance benchmarks

### storage size

| type | bytes | notes |
|------|-------|-------|
| `INTEGER` | 4 | 2.1 billion max |
| `BIGINT` | 8 | 9.2 quintillion max |
| `NUMERIC(19,4)` | 11-13 | 2 bytes per 4 digits + 3-8 overhead |
| `NUMERIC(24,12)` | 15-17 | for pico-precision |

**numeric is variable-length**: 2 bytes per 4 decimal digits, plus 3-8 bytes overhead. a simple "1" takes 5 bytes minimum. the declared precision is a maximum, not a fixed allocation.

### arithmetic speed

from [cybertec benchmark](https://www.cybertec-postgresql.com/en/int4-vs-int8-vs-uuid-vs-numeric-performance-on-bigger-joins/):

| type | join time | vs int4 |
|------|-----------|---------|
| `int4` | 3718ms | baseline |
| `int8` | 3745ms | +0.7% |
| `uuid` | 4038ms | +7.8% |
| `numeric` | 5122ms | **+26.8%** |

from [xendit benchmark](https://blog.xendit.engineer/benchmarking-pg-numeric-integer-9c593d7af67e):
- numeric arithmetic is "very slow compared to the integer types"
- integer uses cpu-native instructions
- numeric is implemented partly in software

### index size

| type | index size |
|------|------------|
| `int4` | 107 MB |
| `int8` | 150 MB |
| `numeric` | 150 MB |
| `uuid` | 237 MB |

---

## postgresql extensions

### fixeddecimal (2ndquadrant)

the only notable extension for monetary storage.

**repo**: [github.com/2ndQuadrant/fixeddecimal](https://github.com/2ndQuadrant/fixeddecimal)

```sql
-- use instead of NUMERIC
CREATE TABLE prices (
  amount FIXEDDECIMAL(17, 2) NOT NULL
);
```

**features:**
- subset of NUMERIC with bigint-like performance
- fixed 2 decimal places by default (configurable via recompile)
- works with postgresql 9.5+, tested on 12
- supports postgres-xl

**limitations:**
- requires extension installation (not always available on managed postgres)
- scale is compile-time constant (default 2)
- cannot change scale without recompile
- not widely adopted

**verdict**: minor improvement over bigint. the compile-time scale limitation makes it unsuitable for iso-price's variable exponent pattern.

### why no iso 4217 extension exists

no postgresql extension implements iso 4217 exponents because:
1. the pattern is trivial: `amount / 10^exponent`
2. exponent varies by currency (0, 2, 3) and usecase (6, 9, 12 for micro-payments)
3. a fixed extension can't handle variable precision elegantly

---

## why bigint + exponent wins

### stripe's design

stripe stores all amounts as integers in minor units:

```json
{
  "amount": 5037,
  "currency": "usd"
}
```

they handle variable precision via [unit_amount_decimal](https://docs.stripe.com/api/prices/object):
- `unit_amount`: integer cents (null for sub-cent)
- `unit_amount_decimal`: string with up to 12 decimals

this is exactly the iso-price pattern: integer + variable exponent.

### iso 4217 alignment

iso 4217 defines currency exponents:
- exponent 0: JPY, KRW (no minor unit)
- exponent 2: USD, EUR, GBP (cents)
- exponent 3: BHD, KWD, OMR (fils)

the bigint + exponent pattern maps directly to this standard.

### sub-cent use cases

for llm token costs ($0.000003/token), the pattern extends naturally:
- exponent 6 = micro-dollars
- exponent 9 = nano-dollars
- exponent 12 = pico-dollars (requires bigint for amounts > $9,007)

---

## avoid these patterns

### 1. postgresql money type

```sql
-- ❌ don't use
amount MONEY NOT NULL
```

problems:
- locale-dependent (lc_monetary)
- fixed 2 decimal places
- truncates on division (`$1.00 / 3 = $0.33`, loses a cent)
- portability hazard on db restore

### 2. float / double precision

```sql
-- ❌ never use for money
amount DOUBLE PRECISION NOT NULL
```

problems:
- `0.1 + 0.2 != 0.3` in binary float
- silent precision loss
- "the first rule is never use float data types for money amounts"

### 3. decimal strings

```sql
-- ⚠️ avoid unless you interface with external systems
amount TEXT NOT NULL  -- "50.37"
```

problems:
- no native arithmetic
- parse overhead on every operation
- sort is lexicographic ("9" > "10")

---

## recommended schema for iso-price

```sql
-- pattern: bigint + exponent columns

CREATE TABLE price_record (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- iso-price fields
  amount BIGINT NOT NULL,
  currency CHAR(3) NOT NULL,
  exponent SMALLINT NOT NULL DEFAULT 2,

  -- constraints
  CONSTRAINT chk_amount_non_negative CHECK (amount >= 0),
  CONSTRAINT chk_exponent_valid CHECK (exponent >= 0 AND exponent <= 12)
);

-- index for currency queries
CREATE INDEX idx_price_currency ON price_record(currency);
```

**why this schema:**
1. `BIGINT`: 8 bytes, handles amounts up to $92 quadrillion at cent precision
2. `CHAR(3)`: iso 4217 currency code
3. `SMALLINT`: exponent 0-12 covers all use cases
4. `DEFAULT 2`: most currencies use cents

---

## community consensus

from [crunchy data](https://www.crunchydata.com/blog/working-with-money-in-postgres):
> "use int or bigint if you can work with whole numbers of cents and you don't need fractional cents. this saves space and offers better performance."

from [rietta](https://rietta.com/blog/postgresql-currency-types/):
> "store money as cents in an INTEGER field ensures exact calculations."

from [cardinalby](https://cardinalby.github.io/blog/post/best-practices/storing-currency-values-data-types/):
> "one of the popular approaches (used by stripe) is to store an integer number of minor units. simply put, you store $5 as 500 cents."

---

## sources

- [crunchy data: work with money in postgres](https://www.crunchydata.com/blog/working-with-money-in-postgres)
- [postgresql docs: numeric types](https://www.postgresql.org/docs/current/datatype-numeric.html)
- [postgresql docs: monetary types](https://www.postgresql.org/docs/current/datatype-money.html)
- [cybertec: int4 vs int8 vs uuid vs numeric performance](https://www.cybertec-postgresql.com/en/int4-vs-int8-vs-uuid-vs-numeric-performance-on-bigger-joins/)
- [xendit: benchmark postgres numeric and integer](https://blog.xendit.engineer/benchmarking-pg-numeric-integer-9c593d7af67e)
- [2ndquadrant: fixeddecimal extension](https://github.com/2ndQuadrant/fixeddecimal)
- [stripe api: price object](https://docs.stripe.com/api/prices/object)
- [cardinalby: store currency values](https://cardinalby.github.io/blog/post/best-practices/storing-currency-values-data-types/)
- [rietta: store currency in postgresql](https://rietta.com/blog/postgresql-currency-types/)
- [vadosware: a safer price type in postgres](https://vadosware.io/post/a-safer-price-type-in-postgres)
- [iso 4217 wikipedia](https://en.wikipedia.org/wiki/ISO_4217)
