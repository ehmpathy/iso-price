# iso_price postgresql extension

usage and installation guide for the iso_price postgresql extension.

→ for implementation details, see [per303.implementation](./per303.persistence.postgres.extension.implementation.[guide].md)
→ for publication guide, see [per304.publication](./per304.persistence.postgres.extension.publication.[guide].md)

---

## tl;dr

| type | storage | best for |
|------|---------|----------|
| **iso_price_shape** | composite `(amount, currency, exponent)` | sql arithmetic, aggregation, queries |
| **iso_price_words** | domain over `TEXT` (e.g., `'USD 1_000.50'`) | simplicity, portability, human-readable |

both types support numeric comparison, btree indexes, and currency mismatch detection.

---

## installation

### via npm (recommended)

the simplest approach — works on all platforms (aws rds/aurora, supabase, neon, self-hosted).

```sh
npm install iso-price
cp node_modules/iso-price/dist/postgres/iso_price.init.sql schema/changes/install.iso_price.sql
```

then add to `schema/control.yml`:

```yaml
- type: change
  path: ./changes/install.iso_price.sql
  id: install_iso_price_extension
```

apply with:

```sh
npx sql-schema-control plan   # preview changes
npx sql-schema-control apply  # apply changes
```

→ see [per304.via_npm](./per304.persistence.postgres.extension.publication.via_npm.[guide].md) for full details

### via github release

for non-node.js projects or manual installation.

```sh
# download the release
curl -sLO https://github.com/ehmpathy/iso-price/releases/download/v1.0.0/iso_price.init.sql

# run against your database
psql -h your-host -U your-user -d your-database -f iso_price.init.sql
```

### platform compatibility

| platform | npm / raw sql |
|----------|---------------|
| aws rds / aurora | ✅ |
| supabase | ✅ |
| neon | ✅ |
| google cloud sql | ✅ |
| azure postgres | ✅ |
| self-hosted | ✅ |

### verify installation

```sql
-- check types exist
SELECT typname FROM pg_type WHERE typname LIKE 'iso_price%';

-- test iso_price_shape
SELECT iso_price_shape(5037, 'USD', 2) + iso_price_shape(5, 'USD', 6);

-- test iso_price_words (with underscore separators)
SELECT 'USD 1_000.00'::iso_price_words > 'USD 50.37'::iso_price_words;
-- → true (underscores stripped for numeric comparison)
```

### upgrade

add a new change file for the upgrade and register in `control.yml`:

```yaml
- type: change
  path: ./changes/upgrade.iso_price.v1.1.0.sql
  id: upgrade_iso_price_v1.1.0
```

### uninstall

see [per303.implementation](./per303.persistence.postgres.extension.implementation.[guide].md) for full drop sequence.

---

## iso_price_shape

composite type for structured price storage with native arithmetic.

### schema

```sql
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,
  price iso_price_shape NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### examples

```sql
-- insert with composite literal
INSERT INTO invoice_line_item (description, price)
VALUES ('widget', (5037, 'USD', 2));  -- $50.37

INSERT INTO invoice_line_item (description, price)
VALUES ('api tokens', (5, 'USD', 6));  -- $0.000005

-- arithmetic with auto-normalization
SELECT iso_price_shape(5037, 'USD', 2) + iso_price_shape(5, 'USD', 6);
-- result: (50370005, USD, 6) = $50.370005

-- aggregation
SELECT sum(price) FROM invoice_line_item;  -- auto-normalizes exponents

-- access composite fields
SELECT (price).currency, (price).amount FROM invoice_line_item;

-- comparison
SELECT * FROM invoice_line_item
WHERE price > iso_price_shape(1000, 'USD', 2)  -- > $10.00
ORDER BY price DESC;

-- display value
SELECT iso_price_shape_display(price) FROM invoice_line_item;
-- returns: 50.37, 0.000005, etc
```

### features

- **sql arithmetic** — native `+`, `-`, `*` with auto-normalization
- **sql aggregation** — `sum()` handles mixed exponents automatically
- **comparison** — `<`, `>`, `=` with exponent-aware logic
- **btree index** — proper numeric sort order via operator class
- **currency mismatch detection** — raises error on cross-currency operations
- **type-safe** — database enforces composite structure

### when to use

- you need sql-level aggregation (sum, avg, min, max)
- you want the extension to handle exponent normalization
- performance on large datasets is critical

---

## iso_price_words

domain type over TEXT for human-readable price storage with numeric comparison.

### format

```
{currency} {display_value}
```

uses **numeric separator notation** (ES2021 style): underscore (`_`) for thousands, decimal point (`.`) for decimals.

examples:
- `'USD 50.37'` → $50.37
- `'USD 1_000_000.00'` → $1,000,000.00 (underscores for readability)
- `'USD 0.000_005'` → $0.000005 (micro, underscores in decimal part)
- `'JPY 1_000'` → ¥1,000
- `'EUR 100.00'` → €100.00
- `'BHD 1_234.567'` → 1,234.567 BHD

### schema

```sql
CREATE TABLE invoice_line_item (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  description TEXT NOT NULL,
  price iso_price_words NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### examples

```sql
-- insert (with or without underscore separators)
INSERT INTO invoice_line_item (description, price)
VALUES ('widget', 'USD 50.37');

INSERT INTO invoice_line_item (description, price)
VALUES ('large order', 'USD 1_000_000.00');  -- underscores for readability

INSERT INTO invoice_line_item (description, price)
VALUES ('api tokens', 'USD 0.000_005');  -- micro-dollars

-- numeric comparison works correctly (underscores stripped for comparison)
SELECT * FROM invoice_line_item
WHERE price > 'USD 10.00'
ORDER BY price DESC;
-- returns: 'USD 1_000_000.00', 'USD 100.00', 'USD 50.37' (correct numeric order)
-- raw TEXT would return wrong lexicographic order
```

### features

- **simple schema** — one column
- **human-readable** — immediately clear in logs, debug output, and data exports
- **underscore separators** — supports ES2021 numeric separator notation for readability
- **numeric comparison** — `<`, `>`, `=` strip underscores and compare numerically
- **btree index** — proper numeric sort order via operator class
- **format validation** — domain constraint ensures valid format

### tradeoffs

- **no sql arithmetic** — must convert to iso_price_shape for math
- **no aggregation** — `sum()` not available directly (convert first)
- **parse overhead** — comparison requires string parse

### when to use

- you do all arithmetic in app layer anyway
- schema simplicity is a priority
- prices are primarily for storage/display, not aggregation

---

## conversion

```sql
-- shape to words (for display/logs)
SELECT iso_price_shape_to_words(price) FROM invoice_line_items;
-- (5037, USD, 2) → 'USD 50.37'

-- words to shape (for arithmetic) — underscores stripped automatically
SELECT iso_price_words_to_shape(amount) FROM payment_log;
-- 'USD 50.37' → (5037, USD, 2)
-- 'USD 1_000_000.00' → (100000000, USD, 2)

-- sum words via conversion
SELECT sum(iso_price_words_to_shape(amount)) FROM payment_log;
```

---

## decision matrix

| need | iso_price_shape | iso_price_words |
|------|-----------------|-----------------|
| sql SUM/AVG | ✅ | ❌ (convert first) |
| filter by currency | ✅ `(price).currency` | ❌ (requires parse) |
| simple schema | ❌ | ✅ |
| human-readable | ❌ | ✅ |
| large dataset perf | ✅ | ❌ |
| nosql portability | ❌ | ✅ |

---

## recommendation

**default to iso_price_shape** when:
- you need sql-level aggregation (sum, avg)
- you need the extension to handle exponent normalization
- performance on large datasets is critical

**use iso_price_words** when:
- schema simplicity is paramount
- prices are primarily for storage/display, not computation
- you do all arithmetic in app layer anyway

---

## sources

- [shape vs words concept](./per102.persistence.primitives.shape_vs_words.[article].md) — database-agnostic comparison
- [implementation reference](./per303.persistence.postgres.extension.implementation.[guide].md) — full sql code
- [sql-schema-control](https://github.com/ehmpathy/sql-schema-control) — declarative schema management
