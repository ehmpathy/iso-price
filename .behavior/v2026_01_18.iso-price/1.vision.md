# vision = iso-price

## .what

iso-price is a typescript library for precise, safe price operations. it handles sub-cent precision, bigint safety, and json serialization — so developers can focus on business logic, not arithmetic hazards.

## .who

any developer who works with prices and wants:
- a pit-of-success for how to handle them
- conformance to industry standards (stripe, iso 4217) without a second thought or an eyesore

iso-price supports the full spectrum of price precision:
- **standard prices** — e-commerce, invoices, payments (cents)
- **macro prices** — enterprise deals, real estate, aggregations (dollars)
- **micro prices** — api costs, token usage, serverless invocations (micro/nano-dollars)

common needs iso-price addresses:
- persist prices to databases and apis without serialization hazards
- accumulate amounts without precision loss
- apply markups, taxes, and allocations with explicit round modes
- convert between precisions safely and auditably

## .experience.1: llm inference cost forwarded to customer

a developer builds a saas that wraps llm apis. they need to:
1. track per-customer inference costs at micro-dollar precision
2. persist accumulated costs to their postgres database
3. bill customers at end-of-period with a 1% markup

### track each inference

```ts
import { dividePrice, multiplyPrice } from 'iso-price';

// claude-3-haiku: $0.25 per 1M input tokens, $1.25 per 1M output tokens
const inputRate = dividePrice({ of: '$0.25', by: 1_000_000 });
const outputRate = dividePrice({ of: '$1.25', by: 1_000_000 });

const inputCost = multiplyPrice({ of: inputRate, by: inputTokens });
const outputCost = multiplyPrice({ of: outputRate, by: outputTokens });

// persist to postgres as iso_price_words — no bigint hazards
// (can cast to iso_price_shape via extension for sql arithmetic if needed)
await pg.query(`
  INSERT INTO inference_costs (customer_id, input_cost, output_cost, created_at)
  VALUES ($1, $2, $3, NOW())
`, [customerId, inputCost, outputCost]);
```

### accumulate for bill period

```ts
import { sumPrices, asIsoPrice } from 'iso-price';

// load all costs for the period (already IsoPriceWords from postgres)
const costs = await pg.query(`
  SELECT input_cost, output_cost FROM inference_costs
  WHERE customer_id = $1 AND created_at >= $2
`, [customerId, periodStart]);

// sum all costs — precision preserved automatically
const allCosts = costs.rows.flatMap(row => [row.input_cost, row.output_cost]);
const subtotal = sumPrices(allCosts);
// => 'USD 47.382_847_291'
```

### apply markup and invoice

```ts
import { multiplyPrice, roundPrice, asIsoPriceShape } from 'iso-price';

// apply 1% markup
const withMarkup = multiplyPrice({ of: subtotal, by: 1.01 });
// => 'USD 47.856_675_763...'

// round to cents for invoice and cast to shape for usage with stripe
const invoiceTotal = roundPrice({ of: withMarkup, to: 'centi.x10^-2' }, { format: 'shape' });
// => { amount: 4786n, currency: 'USD' }

// send to stripe
await stripe.invoiceItems.create({
  customer: stripeCustomerId,
  amount: Number(invoiceTotal.amount),              // 4786 cents
  currency: invoiceTotal.currency.toLowerCase(),    // 'usd'
});
```

### why iso-price

without iso-price, this flow requires:
- manual bigint conversion for large accumulated amounts
- custom json serialization to avoid TypeError
- careful exponent alignment when precisions differ
- manual round mode selection

with iso-price:
- `IsoPriceWords` persists to postgres `iso_price_words` domain (or TEXT)
- `sumPrices` handles mixed exponents automatically
- `roundPrice` provides explicit, auditable round behavior
- precision preserved from nano-dollars to final invoice
- sql arithmetic available via `iso_price_shape` extension if needed

## .principles

1. **words by default** — consumers never touch bigint unless they opt in
2. **precision preserved** — sub-cent amounts accumulate without loss
3. **json-safe** — `IsoPriceWords` serializes to any storage layer
4. **explicit round** — precision decrease requires declared mode
5. **mixed input** — operations accept words or shapes interchangeably
