# research.usecase.apiprice = sub-cent precision for api costs

research on how llm apis and serverless compute apis price their services at sub-cent granularity.

---

# context

the wish states:
> "create a comprehensive glossary of price domain objects and operations"

a key usecase for price representation is api usage cost track. these costs are often fractions of a cent per unit (token, request, millisecond).

---

# usecase.1 = llm api token costs

## the problem

llm apis charge per token at rates far below one cent:

| model | input cost per 1M tokens | cost per token |
|-------|-------------------------|----------------|
| gpt-4o | $5.00 | $0.000005 |
| gpt-4o-mini | $0.15 | $0.00000015 |
| gpt-5-nano | $0.05 | $0.00000005 |
| claude-opus-4.5 | $5.00 | $0.000005 |
| claude-sonnet-4.5 | $3.00 | $0.000003 |
| claude-haiku-4.5 | $1.00 | $0.000001 |
| claude-haiku-3 | $0.25 | $0.00000025 |

sources:
- [OpenAI Price](https://openai.com/api/pricing/)
- [Claude Price](https://platform.claude.com/docs/en/about-claude/pricing)
- [LLM API Price Comparison 2025](https://intuitionlabs.ai/articles/llm-api-pricing-comparison-2025)

## precision required

a single token at claude-haiku-3 rates costs $0.00000025 (input).

to represent this in cents: 0.000025 cents
to represent this in micro-cents (1 cent = 1,000,000 micro-cents): 0.025 micro-cents

for accurate accumulation without float error, we need at minimum:
- **8 decimal places in dollars** ($0.00000025)
- **6 decimal places in cents** (0.000025)
- or integer representation in **nano-dollars** (0.25 nano-dollars = 250 pico-dollars)

## real-world accumulation example

a typical claude api call might use:
- 500 input tokens @ $0.000003/token = $0.0015
- 300 output tokens @ $0.000015/token = $0.0045
- total: $0.006 per call

10,000 api calls per day = $60/day

the per-call cost of $0.006 = 0.6 cents = 600,000 nano-cents

---

# usecase.2 = aws lambda serverless costs

## the problem

aws lambda charges per GB-second at extremely precise rates:

| tier | price per GB-second |
|------|---------------------|
| first 6B GB-seconds | $0.0000166667 |
| next 9B GB-seconds | $0.000015 |
| over 15B GB-seconds | $0.000013334 |

plus request charges: $0.20 per 1 million requests = $0.0000002 per request

sources:
- [AWS Lambda Price](https://aws.amazon.com/lambda/pricing/)
- [AWS Lambda Price Guide](https://awsfundamentals.com/blog/aws-lambda-pricing-a-complete-guide-to-understanding-the-cost-of-the-serverless-service)
- [AWS Lambda Cost Breakdown](https://cloudchipr.com/blog/aws-lambda-pricing)

## precision required

a single request at $0.0000002 = 0.00002 cents = 20 nano-cents

for a 128mb lambda that runs for 100ms:
- GB-seconds = 0.128 * 0.1 = 0.0128 GB-seconds
- cost = 0.0128 * $0.0000166667 = $0.000000213
- = 0.0000213 cents = 21.3 nano-cents

to represent these costs without float error:
- **10 decimal places in dollars** ($0.000000213)
- **8 decimal places in cents** (0.0000213)
- or integer representation in **pico-dollars** (213 pico-dollars)

## real-world accumulation example

100,000 lambda invocations per month:
- 100,000 requests @ $0.0000002 = $0.02
- 100,000 * 0.0128 GB-seconds @ $0.0000166667 = $21.33
- total: ~$21.35/month

each individual invocation costs ~$0.000000213, which must accumulate precisely to $21.35 over 100,000 invocations.

---

# usecase.3 = combined api cost track

## the problem

a typical application might track costs from multiple sources:

| source | unit cost | precision needed |
|--------|-----------|------------------|
| openai gpt-4o | $0.000005/token | nano-dollars |
| claude haiku | $0.00000025/token | nano-dollars |
| aws lambda | $0.000000213/invocation | pico-dollars |
| aws api gateway | $0.0000035/request | nano-dollars |

the aggregate cost must be tracked with sufficient precision to avoid cumulative float error.

## industry pattern: micro-dollars and nano-dollars

from [hacker news discussion](https://news.ycombinator.com/item?id=20575702):

> "any competent ad-tech system will use a similar approach: integer number of micro-dollars, nano-dollars, etc."

> "you want a fair amount of precision, so just track via whole cents isn't enough, but you want that precision to be (linearly) equally distributed across the value space so that you can make intuitive guarantees about how much error can accumulate."

## precision hierarchy

| unit | relation to dollar | decimal places | integer name |
|------|-------------------|----------------|--------------|
| dollar | 1 | 0 | dollar |
| cent | 0.01 | 2 | cent |
| mill | 0.001 | 3 | mill |
| micro-cent | 0.000001 | 6 | micro-cent |
| micro-dollar | 0.000001 | 6 | micro-dollar |
| nano-cent | 0.000000001 | 9 | nano-cent |
| nano-dollar | 0.000000001 | 9 | nano-dollar |
| pico-dollar | 0.000000000001 | 12 | pico-dollar |

---

# iso 4217 limitations

## standard minor units

iso 4217 defines "exponent" for each currency:
- exponent 0: no minor unit (JPY, KRW)
- exponent 2: 100 minor units (USD, EUR, GBP) = cents
- exponent 3: 1000 minor units (BHD, KWD, OMR) = fils

sources:
- [ISO 4217 Wikipedia](https://en.wikipedia.org/wiki/ISO_4217)
- [Adyen Currency Codes](https://docs.adyen.com/development-resources/currency-codes/)

## the gap

iso 4217 does not define units smaller than the standard minor unit.

for USD:
- standard: cents (exponent 2)
- not defined: mills, micro-cents, nano-cents

for api cost track, we need 6-12 decimal places, far beyond iso 4217 standard.

---

# solution patterns

## pattern.1: extended exponent

extend the iso 4217 exponent concept:

```ts
interface IsoPriceShape {
  amount: number;       // integer in minor units
  currency: string;     // ISO 4217 code
  exponent?: number;    // decimal places (default from ISO 4217)
}

// standard USD price: $50.37
{ amount: 5037, currency: 'USD' }  // exponent defaults to 2

// micro-cent precision: $0.000005 per token
{ amount: 5, currency: 'USD', exponent: 6 }  // 5 micro-dollars

// nano-dollar precision: $0.000000213 per lambda
{ amount: 213, currency: 'USD', exponent: 9 }  // 213 nano-dollars
```

## pattern.2: fixed high-precision unit

always use a fixed high-precision unit (e.g., nano-dollars):

```ts
interface IsoPriceShape {
  amount: number;       // integer in nano-dollars (exponent 9)
  currency: string;     // ISO 4217 code
}

// $50.37 = 50,370,000,000 nano-dollars
{ amount: 50_370_000_000, currency: 'USD' }

// $0.000005 = 5,000 nano-dollars
{ amount: 5_000, currency: 'USD' }

// $0.000000213 = 213 nano-dollars
{ amount: 213, currency: 'USD' }
```

## pattern.3: commercetools high-precision money

from [commercetools api types](https://docs.commercetools.com/api/types):

> "polymorphic base read-only money type that holds money in cent precision or high precision (in sub-cents)"

> "to define prices that use more fraction digits than the default, use HighPrecisionMoneyDraft"

```ts
// standard precision
{ centAmount: 5037, currencyCode: 'USD' }

// high precision
{ centAmount: 5037, currencyCode: 'USD', fractionDigits: 6 }
```

---

# recommendation for iso-price

## support variable exponent

allow explicit exponent override for high-precision usecases:

```ts
// standard usecase: e-commerce
const price = { amount: 5037, currency: 'USD' };  // $50.37

// api cost usecase: per-token cost
const tokenCost = { amount: 5, currency: 'USD', exponent: 6 };  // $0.000005

// api cost usecase: per-lambda cost
const lambdaCost = { amount: 213, currency: 'USD', exponent: 9 };  // $0.000000213
```

## words format for high precision

extend IsoPriceWords to support high-precision representation:

```
$0.000005        // 5 micro-dollars
$0.000000213     // 213 nano-dollars
USD 0.000005     // code-prefix format
0.000005 USD     // code-suffix format
```

## operations must preserve precision

all arithmetic operations must:
- preserve the highest precision of operands
- avoid float error via integer arithmetic
- support mixed-precision operands (normalize to highest precision)

```ts
// add costs with different precision
sumPrices(
  { amount: 5037, currency: 'USD' },           // $50.37 (exponent 2)
  { amount: 5, currency: 'USD', exponent: 6 }  // $0.000005 (exponent 6)
)
// result: { amount: 50_370_005, currency: 'USD', exponent: 6 }  // $50.370005
```

---

# sources

- [OpenAI Price](https://openai.com/api/pricing/)
- [Claude Price Docs](https://platform.claude.com/docs/en/about-claude/pricing)
- [LLM API Price Comparison 2025](https://intuitionlabs.ai/articles/llm-api-pricing-comparison-2025)
- [AWS Lambda Price](https://aws.amazon.com/lambda/pricing/)
- [AWS Lambda Price Guide](https://awsfundamentals.com/blog/aws-lambda-pricing-a-complete-guide-to-understanding-the-cost-of-the-serverless-service)
- [ISO 4217 Wikipedia](https://en.wikipedia.org/wiki/ISO_4217)
- [Adyen Currency Codes](https://docs.adyen.com/development-resources/currency-codes/)
- [commercetools API Types](https://docs.commercetools.com/api/types)
- [Why integers for money (Hacker News)](https://news.ycombinator.com/item?id=20575702)
- [Precision Matters: Cents vs Float](https://www.pullrequest.com/blog/precision-matters-why-using-cents-instead-of-floating-point-for-transaction-amounts-is-crucial/)
