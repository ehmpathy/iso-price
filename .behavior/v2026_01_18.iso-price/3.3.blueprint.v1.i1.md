# blueprint = iso-price

implementation blueprint for the iso-price package.

---

## context

- **wish**: `.behavior/v2026_01_18.iso-price/0.wish.md`
- **vision**: `.behavior/v2026_01_18.iso-price/1.vision.md`
- **criteria**: `.behavior/v2026_01_18.iso-price/2.criteria.blueprint.md`
- **research**: `.behavior/v2026_01_18.iso-price/3.1.research.claims.v1.i*.md`
- **distill**: `.behavior/v2026_01_18.iso-price/3.2.distill.domain._.v1.i1.md`

---

## phase.0: package rename

rename `iso-price` to `iso-price` and update all references.

### tasks

| task | files | description |
| ---- | ----- | ----------- |
| p0.1 | `package.json` | rename package to `iso-price` |
| p0.2 | `*` | sedreplace `iso-price` → `iso-price` across codebase |
| p0.3 | `*` | sedreplace `Price` → `IsoPrice` in domain object references |

### tests

- verify `npm run build` succeeds
- verify `npm run test:types` succeeds

---

## phase.1: domain objects

implement the core type definitions.

### file structure

```
src/domain.objects/
├── IsoPrice.ts                    # union type
├── IsoPriceShape.ts               # structured DomainLiteral
├── IsoPriceWords.ts               # branded template literal type
├── IsoPriceHuman.ts               # branded string type
├── IsoPriceExponent.ts            # exponent enum
├── IsoPriceRoundMode.ts           # round mode enum
└── IsoCurrency.ts                 # currency enum
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p1.1 | `IsoPriceExponent.ts` | define `IsoPriceExponent` enum |
| p1.2 | `IsoPriceRoundMode.ts` | define `IsoPriceRoundMode` enum |
| p1.3 | `IsoCurrency.ts` | define `IsoCurrency` enum (top 25 currencies) |
| p1.4 | `IsoPriceWords.ts` | define `IsoPriceWords<TCurrency>` branded type via `AsOfGlossary` |
| p1.5 | `IsoPriceHuman.ts` | define `IsoPriceHuman` branded type via `AsOfGlossary` |
| p1.6 | `IsoPriceShape.ts` | define `IsoPriceShape<TCurrency, TExponent>` DomainLiteral |
| p1.7 | `IsoPrice.ts` | define `IsoPrice<TCurrency>` union type |

### tests

unit tests (compile-time + runtime):

| test file | covers |
| --------- | ------ |
| `IsoPriceExponent.test.ts` | enum iteration, type constraint |
| `IsoPriceRoundMode.test.ts` | enum iteration, type constraint |
| `IsoCurrency.test.ts` | enum iteration, type constraint |
| `IsoPriceShape.test.ts` | DomainLiteral instantiation, bigint amount |
| `IsoPriceWords.test.ts` | branded type assignability |
| `IsoPriceHuman.test.ts` | branded type assignability |
| `IsoPrice.test.ts` | union type accepts all variants |

---

## phase.2: type guards

implement runtime type check functions.

### file structure

```
src/domain.operations/guard/
├── isIsoPrice.ts
├── isIsoPrice.test.ts
├── isIsoPriceWords.ts
├── isIsoPriceWords.test.ts
├── isIsoPriceShape.ts
├── isIsoPriceShape.test.ts
├── isIsoPriceHuman.ts
└── isIsoPriceHuman.test.ts
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p2.1 | `isIsoPriceWords.ts` | type guard + `.assure()` method |
| p2.2 | `isIsoPriceShape.ts` | type guard for shape validation |
| p2.3 | `isIsoPriceHuman.ts` | type guard for human format |
| p2.4 | `isIsoPrice.ts` | union type guard (words \| shape \| human) |

### tests

unit tests (data-driven caselist):

```ts
// c.1: format.words
const IS_WORDS_CASES = [
  { given: { input: 'USD 50.37' }, expect: { output: true } },
  { given: { input: 'EUR 50.37' }, expect: { output: true } },
  { given: { input: 'JPY 1_000' }, expect: { output: true } },
  { given: { input: 'USD 0.000_003' }, expect: { output: true } },
  { given: { input: 'USD 1_000_000.00' }, expect: { output: true } },
  { given: { input: 'USD 1,000,000.00' }, expect: { output: false } },  // commas not valid in words
  { given: { input: '$50.37' }, expect: { output: false } },            // symbols not allowed
  { given: { input: 'fifty bucks' }, expect: { output: false } },
  { given: { input: null }, expect: { output: false } },
];

// c.1b: format.human
const IS_HUMAN_CASES = [
  { given: { input: '$50.37' }, expect: { output: true } },
  { given: { input: '€50.37' }, expect: { output: true } },
  { given: { input: '¥1,000' }, expect: { output: true } },
  { given: { input: '$1,000,000.00' }, expect: { output: true } },
  { given: { input: '50.37' }, expect: { output: false } },             // no symbol
  { given: { input: 'USD 50.37' }, expect: { output: false } },         // code-prefix is words, not human
];

// c.2: format.shape
const IS_SHAPE_CASES = [
  { given: { input: { amount: 5037n, currency: 'USD' } }, expect: { output: true } },
  { given: { input: { amount: 1000n, currency: 'JPY' } }, expect: { output: true } },
  { given: { input: { amount: 3n, currency: 'USD', exponent: 'micro.x10^-6' } }, expect: { output: true } },
  { given: { input: '$50.37' }, expect: { output: false } },
  { given: { input: 'USD 50.37' }, expect: { output: false } },
];

// union guard
const IS_PRICE_CASES = [
  { given: { input: 'USD 50.37' }, expect: { output: true } },
  { given: { input: { amount: 5037n, currency: 'USD' } }, expect: { output: true } },
  { given: { input: '$50.37' }, expect: { output: true } },
  { given: { input: 'invalid' }, expect: { output: false } },
  { given: { input: null }, expect: { output: false } },
];
```

| test file | covers |
| --------- | ------ |
| `isIsoPriceWords.test.ts` | c.1: valid words, underscores, no commas, no symbols |
| `isIsoPriceShape.test.ts` | c.2: valid shapes, bigint validation, exponent |
| `isIsoPriceHuman.test.ts` | c.1b: valid symbols, commas allowed |
| `isIsoPrice.test.ts` | union acceptance, rejection of invalid |

---

## phase.3: cast functions

implement format conversion functions.

### file structure

```
src/domain.operations/cast/
├── asIsoPrice.ts
├── asIsoPrice.test.ts
├── asIsoPriceWords.ts
├── asIsoPriceWords.test.ts
├── asIsoPriceShape.ts
├── asIsoPriceShape.test.ts
├── asIsoPriceHuman.ts
└── asIsoPriceHuman.test.ts
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p3.1 | `asIsoPriceShape.ts` | convert any IsoPrice to shape; accept `{ amount: number \| bigint }` |
| p3.2 | `asIsoPriceWords.ts` | convert any IsoPrice to words format |
| p3.3 | `asIsoPriceHuman.ts` | convert any IsoPrice to symbol format |
| p3.4 | `asIsoPrice.ts` | normalize any input to IsoPriceWords; handle symbol → code map |

### tests

unit tests (data-driven caselist):

```ts
// c.3: cast - asIsoPrice
const AS_ISO_PRICE_CASES = [
  { given: { input: '$50.37' }, expect: { output: 'USD 50.37' } },
  { given: { input: '$50.37', options: { currency: 'CAD' } }, expect: { output: 'CAD 50.37' } },
  { given: { input: '$50.37', options: { currency: 'AUD' } }, expect: { output: 'AUD 50.37' } },
  { given: { input: 'USD 50.37' }, expect: { output: 'USD 50.37' } },
  { given: { input: { amount: 5037n, currency: 'USD' } }, expect: { output: 'USD 50.37' } },
  { given: { input: '€50.37' }, expect: { output: 'EUR 50.37' } },
  { given: { input: '¥1000' }, expect: { output: 'JPY 1_000' } },
  { given: { input: '$1,000,000.00' }, expect: { output: 'USD 1_000_000.00' } },  // commas normalized to underscores
  { given: { input: 'USD 1,000,000.00' }, expect: { output: 'USD 1_000_000.00' } },
  // failfast: symbol/currency mismatch
  { given: { input: '€50.37', options: { currency: 'USD' } }, expect: { error: 'symbol € does not match currency USD' } },
  { given: { input: '$50.37', options: { currency: 'EUR' } }, expect: { error: 'symbol $ does not match currency EUR' } },
];

// c.3: cast - asIsoPriceShape
const AS_ISO_PRICE_SHAPE_CASES = [
  { given: { input: 'USD 50.37' }, expect: { output: { amount: 5037n, currency: 'USD' } } },
  { given: { input: { amount: 5037, currency: 'USD' } }, expect: { output: { amount: 5037n, currency: 'USD' } } },
  { given: { input: '$5' }, expect: { output: { amount: 500n, currency: 'USD' } } },
  { given: { input: 'USD 0.000003' }, expect: { output: { amount: 3n, currency: 'USD', exponent: 'micro.x10^-6' } } },
  { given: { input: 'JPY 1000' }, expect: { output: { amount: 1000n, currency: 'JPY' } } },
  { given: { input: 'BHD 1.234' }, expect: { output: { amount: 1234n, currency: 'BHD' } } },
];

// c.3: cast - asIsoPriceWords
const AS_ISO_PRICE_WORDS_CASES = [
  { given: { input: { amount: 5037n, currency: 'USD' } }, expect: { output: 'USD 50.37' } },
  { given: { input: { amount: 3n, currency: 'USD', exponent: 'micro.x10^-6' } }, expect: { output: 'USD 0.000003' } },
];

// c.3: cast - asIsoPriceHuman
const AS_ISO_PRICE_HUMAN_CASES = [
  { given: { input: 'USD 50.37' }, expect: { output: '$50.37' } },
  { given: { input: 'EUR 50.37' }, expect: { output: '€50.37' } },
  { given: { input: 'JPY 1_000' }, expect: { output: '¥1,000' } },
  { given: { input: 'USD 1_000_000.00' }, expect: { output: '$1,000,000.00' } },
];

// c.12: bigint - cast functions accept number and convert to bigint
const BIGINT_COERCION_CASES = [
  { given: { input: { amount: 5037, currency: 'USD' } }, expect: { output: { amount: 5037n, currency: 'USD' } } },
  // high-precision arithmetic via bigint
  { given: { input: 'USD 50.370_000_000_000_213' }, expect: { output: { amount: 5_037_000_000_000_213n, currency: 'USD', exponent: 'pico.x10^-12' } } },
];

// c.13: serialize - JSON serialization via IsoPriceWords
const SERIALIZE_CASES = [
  // words serialize trivially (string)
  { given: { input: { amount: 25_000_000_000_000_000n, currency: 'USD', exponent: 'nano.x10^-9' } }, expect: { output: 'USD 25_000_000.000_000_000' } },
  // round-trip restoration
  { given: { input: 'USD 25_000_000.000_000_000' }, expect: { output: { amount: 25_000_000_000_000_000n, currency: 'USD', exponent: 'nano.x10^-9' } } },
];

// c.14: currency.iso4217 - standard currencies with automatic exponent defaults
const ISO4217_CASES = [
  { given: { input: '$50.37' }, expect: { output: 'USD 50.37' } },    // 2-decimal default
  { given: { input: '€50.37' }, expect: { output: 'EUR 50.37' } },    // 2-decimal default
  { given: { input: '¥1000' }, expect: { output: 'JPY 1_000' } },     // 0-decimal default
  { given: { input: '₩1000' }, expect: { output: 'KRW 1_000' } },     // 0-decimal default
  // shape format shows exponent defaults
  { given: { input: 'USD 50.37' }, expect: { output: { amount: 5037n, currency: 'USD' } } },  // centi.x10^-2
  { given: { input: 'JPY 1000' }, expect: { output: { amount: 1000n, currency: 'JPY' } } },   // whole.x10^0
  { given: { input: 'BHD 1.234' }, expect: { output: { amount: 1234n, currency: 'BHD' } } },  // milli.x10^-3
];

// c.15: currency.custom - custom currencies (crypto) accepted
const CUSTOM_CURRENCY_CASES = [
  { given: { input: { amount: 100_000_000, currency: 'BTC', exponent: 'nano.x10^-9' } }, expect: { output: { amount: 100_000_000n, currency: 'BTC', exponent: 'nano.x10^-9' } } },
  { given: { input: 'BTC 1.00000000' }, expect: { output: 'BTC 1.00000000' } },
  { given: { input: 'ETH 1.000000000000000000' }, expect: { output: 'ETH 1.000000000000000000' } },
];
```

| test file | covers |
| --------- | ------ |
| `asIsoPrice.test.ts` | all input variants, currency override, symbol/currency mismatch error |
| `asIsoPriceWords.test.ts` | shape→words, human→words, passthrough |
| `asIsoPriceShape.test.ts` | words→shape, number→bigint coercion, exponent preservation |
| `asIsoPriceHuman.test.ts` | words→human, shape→human, locale format |

---

## phase.4: precision operations

implement exponent and round operations.

### file structure

```
src/domain.operations/precision/
├── getIsoPriceExponentByCurrency.ts
├── getIsoPriceExponentByCurrency.test.ts
├── setPricePrecision.ts
├── setPricePrecision.test.ts
├── roundPrice.ts
└── roundPrice.test.ts
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p4.1 | `getIsoPriceExponentByCurrency.ts` | lookup standard exponent (JPY→whole, BHD→milli, etc) |
| p4.2 | `setPricePrecision.ts` | change precision; lossy decrease requires round mode |
| p4.3 | `roundPrice.ts` | semantic alias for setPricePrecision with half-up default |

### tests

unit tests (data-driven caselist):

```ts
// getIsoPriceExponentByCurrency
const CURRENCY_EXPONENT_CASES = [
  { given: { input: 'USD' }, expect: { output: 'centi.x10^-2' } },
  { given: { input: 'EUR' }, expect: { output: 'centi.x10^-2' } },
  { given: { input: 'JPY' }, expect: { output: 'whole.x10^0' } },
  { given: { input: 'KRW' }, expect: { output: 'whole.x10^0' } },
  { given: { input: 'BHD' }, expect: { output: 'milli.x10^-3' } },
  { given: { input: 'KWD' }, expect: { output: 'milli.x10^-3' } },
  { given: { input: 'OMR' }, expect: { output: 'milli.x10^-3' } },
  { given: { input: 'TND' }, expect: { output: 'milli.x10^-3' } },
  { given: { input: 'BTC' }, expect: { output: 'centi.x10^-2' } }, // unknown defaults
];

// c.9: precision.change - setPricePrecision
const SET_PRECISION_CASES = [
  // lossless increase
  { given: { input: { of: 'USD 50.37', to: 'micro.x10^-6' } }, expect: { output: 'USD 50.370_000' } },
  // lossy decrease - default half-up
  { given: { input: { of: 'USD 50.370_005', to: 'centi.x10^-2' } }, expect: { output: 'USD 50.37' } },
  // lossy decrease - explicit round
  { given: { input: { of: 'USD 50.370_005', to: 'centi.x10^-2' }, options: { round: 'floor' } }, expect: { output: 'USD 50.37' } },
  // c.10: all round modes
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2' } }, expect: { output: 'USD 5.56' } },  // default half-up
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2' }, options: { round: 'floor' } }, expect: { output: 'USD 5.55' } },
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2' }, options: { round: 'ceil' } }, expect: { output: 'USD 5.56' } },
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2' }, options: { round: 'half-up' } }, expect: { output: 'USD 5.56' } },
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2' }, options: { round: 'half-down' } }, expect: { output: 'USD 5.55' } },
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2' }, options: { round: 'half-even' } }, expect: { output: 'USD 5.56' } },
  // shape output
  { given: { input: { of: 'USD 50.37', to: 'micro.x10^-6' }, options: { format: 'shape' } }, expect: { output: { amount: 50_370_000n, currency: 'USD', exponent: 'micro.x10^-6' } } },
];

// c.11: precision.roundPrice
const ROUND_PRICE_CASES = [
  { given: { input: { of: 'USD 50.375', to: 'centi.x10^-2' } }, expect: { output: 'USD 50.38' } },
  { given: { input: { of: 'USD 50.374', to: 'centi.x10^-2' } }, expect: { output: 'USD 50.37' } },
  { given: { input: { of: 'USD 47.856_675', to: 'centi.x10^-2' } }, expect: { output: 'USD 47.86' } },
  { given: { input: { of: 'USD 5.555', to: 'centi.x10^-2', mode: 'floor' } }, expect: { output: 'USD 5.55' } },
];
```

| test file | covers |
| --------- | ------ |
| `getIsoPriceExponentByCurrency.test.ts` | known currencies, unknown default |
| `setPricePrecision.test.ts` | lossless increase, lossy decrease, all round modes |
| `roundPrice.test.ts` | default half-up, explicit modes, format options |

---

## phase.5: arithmetic operations

implement core price arithmetic.

### file structure

```
src/domain.operations/arithmetic/
├── sumPrices.ts
├── sumPrices.test.ts
├── subPrices.ts
├── subPrices.test.ts
├── multiplyPrice.ts
├── multiplyPrice.test.ts
├── dividePrice.ts
├── dividePrice.test.ts
├── allocatePrice.ts
└── allocatePrice.test.ts
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p5.1 | `sumPrices.ts` | sum prices; spread + array syntax; export alias `addPrices` |
| p5.2 | `subPrices.ts` | subtract prices; spread + array syntax |
| p5.3 | `multiplyPrice.ts` | multiply by scalar; preserve precision |
| p5.4 | `dividePrice.ts` | divide by scalar; preserve precision |
| p5.5 | `allocatePrice.ts` | lossless split by parts or ratios; remainder strategies |

### tests

unit tests (data-driven caselist):

```ts
// c.4: sumPrices
const SUM_CASES = [
  { given: { input: ['USD 10.00', 'USD 20.00'] }, expect: { output: 'USD 30.00' } },
  { given: { input: ['USD 1.11', 'USD 2.22', 'USD 3.33'] }, expect: { output: 'USD 6.66' } },
  // mixed precision
  { given: { input: ['USD 10.00', 'USD 0.001_000'] }, expect: { output: 'USD 10.001_000' } },
  // shape input (number converted to bigint internally)
  { given: { input: [{ amount: 1000, currency: 'USD' }, { amount: 2000, currency: 'USD' }] }, expect: { output: 'USD 30.00' } },
  // mixed exponents normalize to highest precision
  { given: { input: ['USD 50.37', 'USD 0.000005'] }, expect: { output: 'USD 50.370005' } },
  // array syntax with format option
  { given: { input: ['USD 10.00', 'USD 20.00'], options: { format: 'shape' } }, expect: { output: { amount: 3000n, currency: 'USD' } } },
  // currency mismatch
  { given: { input: ['USD 10.00', 'EUR 20.00'] }, expect: { error: 'currency mismatch' } },
];

// c.5: subPrices
const SUB_CASES = [
  { given: { input: ['USD 50.00', 'USD 20.00'] }, expect: { output: 'USD 30.00' } },
  // negative results allowed (for refunds, debits)
  { given: { input: ['USD 10.00', 'USD 50.00'] }, expect: { output: 'USD -40.00' } },
  // array syntax with format option
  { given: { input: ['USD 50.00', 'USD 20.00'], options: { format: 'shape' } }, expect: { output: { amount: 3000n, currency: 'USD' } } },
];

// c.6: multiplyPrice
const MULTIPLY_CASES = [
  { given: { input: { of: 'USD 10.00', by: 3 } }, expect: { output: 'USD 30.00' } },
  { given: { input: { of: 'USD 10.00', by: 1.5 } }, expect: { output: 'USD 15.00' } },
  { given: { input: { of: 'USD 10.00', by: 0.333 } }, expect: { output: 'USD 3.33' } }, // tests round
  // scale up (e.g., tax markup)
  { given: { input: { of: 'USD 100.00', by: 1.08 } }, expect: { output: 'USD 108.00' } },
  // scale down (e.g., discount)
  { given: { input: { of: 'USD 100.00', by: 0.90 } }, expect: { output: 'USD 90.00' } },
  // high-precision input preserves precision
  { given: { input: { of: 'USD 0.000_001', by: 7 } }, expect: { output: 'USD 0.000_007' } },
  // shape output when needed
  { given: { input: { of: 'USD 10.00', by: 3 }, options: { format: 'shape' } }, expect: { output: { amount: 3000n, currency: 'USD' } } },
  // explicit round modes
  { given: { input: { of: 'USD 10.00', by: 0.333 }, options: { round: 'floor' } }, expect: { output: 'USD 3.33' } },
  { given: { input: { of: 'USD 10.00', by: 0.336 }, options: { round: 'ceil' } }, expect: { output: 'USD 3.37' } },
];

// c.7: dividePrice
const DIVIDE_CASES = [
  { given: { input: { of: '$0.25', by: 1_000_000 } }, expect: { output: 'USD 0.000_000_250' } },
  { given: { input: { of: 'USD 100.00', by: 3 } }, expect: { output: 'USD 33.33' } }, // tests round
  // even division
  { given: { input: { of: 'USD 10.00', by: 4 } }, expect: { output: 'USD 2.50' } },
  // high-precision input preserves precision
  { given: { input: { of: 'USD 0.000_021', by: 3 } }, expect: { output: 'USD 0.000_007' } },
  // shape output when needed
  { given: { input: { of: 'USD 10.00', by: 4 }, options: { format: 'shape' } }, expect: { output: { amount: 250n, currency: 'USD' } } },
  // explicit round modes
  { given: { input: { of: 'USD 10.00', by: 3 }, options: { round: 'floor' } }, expect: { output: 'USD 3.33' } },
  { given: { input: { of: 'USD 10.00', by: 3 }, options: { round: 'ceil' } }, expect: { output: 'USD 3.34' } },
];

// c.8: allocatePrice
const ALLOCATE_CASES = [
  // equal parts
  { given: { input: { of: 'USD 10.00', into: { parts: 3 }, remainder: 'first' } }, expect: { output: ['USD 3.34', 'USD 3.33', 'USD 3.33'] } },
  { given: { input: { of: 'USD 10.00', into: { parts: 3 }, remainder: 'last' } }, expect: { output: ['USD 3.33', 'USD 3.33', 'USD 3.34'] } },
  // ratios
  { given: { input: { of: 'USD 5.00', into: { ratios: [7, 3] }, remainder: 'first' } }, expect: { output: ['USD 3.50', 'USD 1.50'] } },
  { given: { input: { of: 'USD 10.00', into: { ratios: [1, 1, 2] }, remainder: 'largest' } }, expect: { output: ['USD 2.50', 'USD 2.50', 'USD 5.00'] } },
  // shape output when needed
  { given: { input: { of: 'USD 10.00', into: { parts: 3 }, remainder: 'first' }, options: { format: 'shape' } }, expect: { output: [{ amount: 334n }, { amount: 333n }, { amount: 333n }] } },
  // lossless invariant
  { given: { input: { of: 'USD 100.00', into: { parts: 7 }, remainder: 'largest' } }, expect: { invariant: 'sum === input' } },
];
```

| test file | covers |
| --------- | ------ |
| `sumPrices.test.ts` | spread syntax, array syntax, mixed precision, currency mismatch error |
| `subPrices.test.ts` | subtraction, negative results, currency mismatch |
| `multiplyPrice.test.ts` | integer multiplier, decimal multiplier, round modes |
| `dividePrice.test.ts` | division, precision preservation, round modes |
| `allocatePrice.test.ts` | equal parts, ratios, all remainder strategies, lossless invariant |

---

## phase.6: statistics

implement statistical operations.

### file structure

```
src/domain.operations/statistics/
├── calcPriceStdev.ts
└── calcPriceStdev.test.ts
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p6.1 | `calcPriceStdev.ts` | standard deviation; spread + array syntax |

### tests

```ts
// c.16: statistics
const STDEV_CASES = [
  { given: { input: ['USD 10.00', 'USD 20.00', 'USD 30.00'] }, expect: { output: 'USD 8.16' } },
  { given: { input: ['USD 5.00', 'USD 5.00', 'USD 5.00'] }, expect: { output: 'USD 0.00' } },
  { given: { input: [] }, expect: { output: null } },
  // array syntax with format option
  { given: { input: ['USD 10.00', 'USD 20.00', 'USD 30.00'], options: { format: 'shape' } }, expect: { output: { amount: 816n, currency: 'USD' } } },
];
```

---

## phase.7: exports and contract

finalize public api.

### file structure

```
src/
├── index.ts                      # re-export from contract
└── contract/
    └── index.ts                  # public api surface
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p7.1 | `contract/index.ts` | export all domain objects and operations |
| p7.2 | `index.ts` | re-export from contract |

### exports checklist

```ts
// domain objects
export { IsoPriceShape, IsoPriceWords, IsoPriceHuman, IsoPrice };
export { IsoPriceExponent, IsoPriceRoundMode, IsoCurrency };

// type guards
export { isIsoPrice, isIsoPriceWords, isIsoPriceShape, isIsoPriceHuman };

// cast functions
export { asIsoPrice, asIsoPriceWords, asIsoPriceShape, asIsoPriceHuman };

// arithmetic
export { sumPrices, addPrices, subPrices, multiplyPrice, dividePrice, allocatePrice };

// precision
export { setPricePrecision, roundPrice, getIsoPriceExponentByCurrency };

// statistics
export { calcPriceStdev };
```

---

## phase.8: acceptance tests

blackbox acceptance tests for vision.experience.1.

### file structure

```
src/__test_assets__/
└── fixtures/
    └── llmCostTrack.fixture.ts

src/contract/
└── index.acceptance.test.ts
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p8.1 | `index.acceptance.test.ts` | full llm cost track flow from vision |

### tests

acceptance test that covers vision.experience.1:

```ts
given('[case1] llm inference cost track', () => {
  when('[t0] before any changes', () => {
    then('dividePrice computes per-token rate at nano precision', async () => {
      const inputRate = dividePrice({ of: '$0.25', by: 1_000_000 });
      expect(inputRate).toEqual('USD 0.000_000_250');
    });
  });

  when('[t1] track each inference', () => {
    then('multiplyPrice computes token cost', async () => {
      const inputRate = dividePrice({ of: '$0.25', by: 1_000_000 });
      const inputCost = multiplyPrice({ of: inputRate, by: 47_382 });
      expect(inputCost).toEqual('USD 0.011_845_500');
    });
  });

  when('[t2] accumulate for bill period', () => {
    then('sumPrices accumulates costs', async () => {
      const costs = ['USD 0.011_845_500', 'USD 47.370_001_970'];
      const subtotal = sumPrices(costs);
      expect(subtotal).toEqual('USD 47.381_847_470');
    });
  });

  when('[t3] apply markup and invoice', () => {
    then('multiplyPrice applies markup', async () => {
      const subtotal = 'USD 47.381_847_470';
      const withMarkup = multiplyPrice({ of: subtotal, by: 1.01 });
      expect(withMarkup).toEqual('USD 47.855_665_944');
    });

    then('roundPrice rounds to cents for stripe', async () => {
      const withMarkup = 'USD 47.855_665_944';
      const invoiceTotal = roundPrice({ of: withMarkup, to: 'centi.x10^-2' }, { format: 'shape' });
      expect(invoiceTotal).toEqual({ amount: 4786n, currency: 'USD' });
    });
  });

  when('[t4] integrate with stripe', () => {
    then('shape provides integer cents', async () => {
      const invoiceTotal = { amount: 4786n, currency: 'USD' };
      expect(Number(invoiceTotal.amount)).toEqual(4786);
      expect(invoiceTotal.currency.toLowerCase()).toEqual('usd');
    });
  });
});
```

---

## test coverage matrix

| phase | scope | type | coverage |
| ----- | ----- | ---- | -------- |
| p0 | package rename | build | `npm run build`, `npm run test:types` |
| p1 | domain objects | unit | type narrow, runtime validation |
| p2 | type guards | unit | data-driven caselist, `.assure()` |
| p3 | cast functions | unit | all input variants, error cases |
| p4 | precision | unit | lossless increase, lossy decrease, all round modes |
| p5 | arithmetic | unit | spread + array syntax, mixed precision, lossless invariants |
| p6 | statistics | unit | stdev computation, edge cases |
| p7 | exports | build | `npm run build`, public api surface |
| p8 | acceptance | acceptance | vision.experience.1 end-to-end |

---

## dependencies

### external packages

| package | version | purpose |
| ------- | ------- | ------- |
| `domain-objects` | `^0.23.0` | DomainLiteral base class |
| `domain-glossaries` | `^1.0.0` | AsOfGlossary branded types |
| `type-fns` | `^1.0.0` | Literalize utility |
| `helpful-errors` | `^1.0.0` | BadRequestError, UnexpectedCodePathError |

### dev packages

| package | version | purpose |
| ------- | ------- | ------- |
| `test-fns` | `^1.0.0` | given/when/then test structure |
| `jest` | `^29.0.0` | test runner |

---

## migration notes

### backwards compatibility

**none.**

the old `Price` interface is **deleted entirely** — not deprecated, not shimmed, not re-exported.

there is **no compatibility layer**. all old code must be updated.

```ts
// ❌ DELETED — this interface no longer exists
interface Price {
  id?: number;
  amount: number;
  currency: Currency;
}

// ❌ DELETED — these functions no longer exist
isAPrice()
asPriceWord()
ofPriceWord()

// ❌ DELETED — this enum no longer exists
enum Currency { ... }
```

**complete replacement:**

```ts
// ✅ NEW — the only price interface
interface IsoPriceShape {
  amount: bigint;         // bigint, not number
  currency: TCurrency;    // generic, not enum
  exponent?: TExponent;   // explicit precision
}

// ✅ NEW — the only price functions
isIsoPrice()
asIsoPriceWords()
asIsoPriceShape()

// ✅ NEW — the only currency enum
enum IsoCurrency { ... }
```

### what this means for consumers

1. **all imports break** — `import { Price } from 'iso-price'` will fail
2. **all usages break** — `Price`, `Currency`, `isAPrice`, `asPriceWord`, `ofPriceWord` do not exist
3. **package name changes** — `iso-price` → `iso-price`
4. **no gradual migration** — update all code or compilation fails

### why no backwards compat

- the old interface conflates precision (number vs bigint)
- the old interface lacks explicit exponent control
- shims would perpetuate the footguns we want to eliminate
- clean break = pit of success for new consumers
