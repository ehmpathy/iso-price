# blackbox criteria = iso-price

experience bounds for the iso-price package.

---

# usecase.1 = declare an IsoPrice

users can declare prices via words or shape, and the library accepts either interchangeably.

## given('a user wants to declare a price')

### when('they provide IsoPriceWords format')

```ts
// symbol prefix
const price: IsoPrice = isIsoPriceWords.assure('$50.37');
const price: IsoPrice = isIsoPriceWords.assure('¥1000');
const price: IsoPrice = isIsoPriceWords.assure('€50.37');

// iso code prefix
const price: IsoPrice = isIsoPriceWords.assure('USD 50.37');
const price: IsoPrice = isIsoPriceWords.assure('JPY 1000');

// iso code suffix
const price: IsoPrice = isIsoPriceWords.assure('50.37 USD');
const price: IsoPrice = isIsoPriceWords.assure('1000 JPY');
```

then('the price is accepted as valid IsoPrice')
  sothat('users can declare prices in human-readable format')

then('IsoPriceWords is a branded string type')
  sothat('type safety is enforced via the brand, not template literals')

then('isIsoPriceWords.assure() validates and returns branded type or throws')
  sothat('invalid strings are caught immediately')

### when('they provide IsoPriceShape format')

```ts
const price: IsoPrice = { amount: 50_37, currency: 'USD' };
const price: IsoPrice = { amount: 1000, currency: 'JPY' };
const price: IsoPrice = { amount: 1_234_567, currency: 'BHD' }; // 3 decimals

// with explicit exponent for high-precision (api costs, etc.)
const tokenCost: IsoPrice = { amount: 5, currency: 'USD', exponent: 'micro.^-6' }; // $0.000005
```

then('the price is accepted as valid IsoPrice')
  sothat('users can declare prices programmatically')

then('amount is in smallest currency unit (minor unit)')
  sothat('no float precision issues occur')

then('exponent is optional and defaults to iso 4217 standard for the currency')
  sothat('standard usecases require no extra configuration')

### when('they provide an invalid shape')

```ts
const price: IsoPrice = { amount: 'fifty' }; // typescript error: amount must be number
const price: IsoPrice = { amount: 50.37 };   // typescript error: amount must be integer
const price: IsoPrice = { currency: 'USD' }; // typescript error: amount required
```

then('typescript rejects it at compile time')
  sothat('invalid shapes are caught before runtime')

### when('they provide an invalid words string')

```ts
const input = 'fifty dollars';
if (isIsoPriceWords(input)) {
  const price: IsoPrice = input; // narrowed to IsoPriceWords
}
// isIsoPriceWords('fifty dollars') => false
// isIsoPriceWords('$50.37') => true
```

then('runtime validation rejects invalid strings')
  sothat('untrusted input is validated before use')

---

# usecase.2 = cast between IsoPrice formats

users can convert between words and shape representations.

## given('a user has an IsoPrice in any format')

### when('they cast to shape via asIsoPriceShape')

```ts
const shape = asIsoPriceShape('$50.37');
// => { amount: 5037, currency: 'USD' }

const shape = asIsoPriceShape({ amount: 5037, currency: 'USD' });
// => { amount: 5037, currency: 'USD' } (passthrough)
```

then('they receive IsoPriceShape')
  sothat('they can use the structured format for calculations')

### when('they cast to words via asIsoPriceWords')

```ts
// default: prefix-symbol format with cents
const words = asIsoPriceWords({ price: { amount: 5037, currency: 'USD' } });
// => '$50.37'

// whole amounts include cents by default
const words = asIsoPriceWords({ price: { amount: 5000, currency: 'USD' } });
// => '$50.00'

// explicit format: prefix-symbol
const words = asIsoPriceWords({
  price: { amount: 5037, currency: 'USD' },
  with: { format: 'prefix-symbol' },
});
// => '$50.37'

// explicit format: prefix-code
const words = asIsoPriceWords({
  price: { amount: 5037, currency: 'USD' },
  with: { format: 'prefix-code' },
});
// => 'USD 50.37'

// explicit format: suffix-code
const words = asIsoPriceWords({
  price: { amount: 5037, currency: 'USD' },
  with: { format: 'suffix-code' },
});
// => '50.37 USD'

// cents: false to omit decimal portion
const words = asIsoPriceWords({
  price: { amount: 5000, currency: 'USD' },
  with: { cents: false },
});
// => '$50'

// combine options
const words = asIsoPriceWords({
  price: { amount: 5000, currency: 'USD' },
  with: { format: 'suffix-code', cents: false },
});
// => '50 USD'

// passthrough if already words
const words = asIsoPriceWords({ price: isIsoPriceWords.assure('$50.37') });
// => '$50.37'
```

then('they receive IsoPriceWords in the specified format')
  sothat('they can display prices to humans in their preferred style')

then('with.cents defaults to true')
  sothat('whole amounts display with decimal suffix by default')

then('with.format defaults to prefix-symbol')
  sothat('localized currency symbols are used by default')

### when('they cast via asIsoPrice')

```ts
const price = asIsoPrice('$50.37');
// => { amount: 5037, currency: 'USD' } (returns shape by default)

const price = asIsoPrice({ amount: 5037, currency: 'USD' });
// => { amount: 5037, currency: 'USD' }
```

then('they receive IsoPriceShape')
  sothat('shape is the canonical programmatic format')

---

# usecase.3 = validate IsoPrice formats

users can check if a value is a valid IsoPrice.

## given('a user has an unknown value')

### when('they check via isIsoPrice')

```ts
isIsoPrice('$50.37')                        // => true
isIsoPrice({ amount: 5037, currency: 'USD' }) // => true
isIsoPrice('fifty dollars')                 // => false
isIsoPrice({ amount: 'fifty' })             // => false
```

then('they receive a boolean')
  sothat('they can validate user input at runtime')

then('the function acts as a typescript type guard')
  sothat('the value is narrowed to IsoPrice after the check')

### when('they check via isIsoPriceWords')

```ts
isIsoPriceWords('$50.37')  // => true
isIsoPriceWords('USD 50')  // => true
isIsoPriceWords({ amount: 5037, currency: 'USD' }) // => false
```

then('they receive a boolean for words format specifically')

### when('they check via isIsoPriceShape')

```ts
isIsoPriceShape({ amount: 5037, currency: 'USD' }) // => true
isIsoPriceShape('$50.37')  // => false
```

then('they receive a boolean for shape format specifically')

---

# usecase.4 = sum prices

users can add multiple prices together.

aliases: `sumPrices`, `priceSum`, `priceSummate`, `priceAdd`

## given('a user has multiple prices in the same currency')

### when('they sum shapes via sumPrices')

```ts
// spread args
const total = sumPrices(
  { amount: 1000, currency: 'USD' },
  { amount: 2000, currency: 'USD' },
  { amount: 550, currency: 'USD' },
);
// => { amount: 3550, currency: 'USD' }

// array
const total = sumPrices([
  { amount: 1000, currency: 'USD' },
  { amount: 2000, currency: 'USD' },
  { amount: 550, currency: 'USD' },
]);
// => { amount: 3550, currency: 'USD' }
```

then('they receive the sum as IsoPriceShape')
  sothat('they can total up line items, invoices, etc.')

then('both spread args and array input are supported')
  sothat('users can choose the most convenient form')

### when('they sum words via sumPrices')

```ts
// spread args
const total = sumPrices(
  '$10.00',
  '$20.00',
  '$5.50',
);
// => { amount: 3550, currency: 'USD' }

// array
const total = sumPrices([
  '$10.00',
  '$20.00',
  '$5.50',
]);
// => { amount: 3550, currency: 'USD' }
```

then('they receive the sum as IsoPriceShape')

### when('they attempt to mix shapes and words')

```ts
sumPrices(
  '$10.00',
  { amount: 2000, currency: 'USD' }, // typescript error: cannot mix formats
);
```

then('typescript rejects it at compile time')
  sothat('format consistency is enforced')

## given('a user has prices in different currencies')

### when('they attempt to sum shapes with mismatched currencies')

```ts
sumPrices(
  { amount: 1000, currency: 'USD' },
  { amount: 1000, currency: 'EUR' }, // typescript error: currency mismatch
);
```

then('typescript rejects it at compile time')
  sothat('users cannot accidentally mix currencies')

### when('they attempt to sum words with mismatched currencies')

```ts
sumPrices(
  '$10.00',
  '€10.00', // runtime error: currency mismatch
);
```

then('an error is thrown at runtime')
  sothat('currency safety is enforced even for dynamic input')

---

# usecase.5 = subtract prices

users can subtract one price from another.

aliases: `subPrices`, `priceSub`, `priceSubtract`

## given('a user has two prices in the same currency')

### when('they subtract shapes via subPrices')

```ts
// spread args
const diff = subPrices(
  { amount: 5000, currency: 'USD' },
  { amount: 2000, currency: 'USD' },
);
// => { amount: 3000, currency: 'USD' }

// array
const diff = subPrices([
  { amount: 5000, currency: 'USD' },
  { amount: 2000, currency: 'USD' },
]);
// => { amount: 3000, currency: 'USD' }
```

then('they receive the difference as IsoPriceShape')
  sothat('they can calculate discounts, balances, etc.')

then('both spread args and array input are supported')
  sothat('users can choose the most convenient form')

### when('they subtract words via subPrices')

```ts
// spread args
const diff = subPrices(
  '$50.00',
  '$20.00',
);
// => { amount: 3000, currency: 'USD' }

// array
const diff = subPrices([
  '$50.00',
  '$20.00',
]);
// => { amount: 3000, currency: 'USD' }
```

then('they receive the difference as IsoPriceShape')

## given('the result would be negative')

### when('they subtract via subPrices')

```ts
const diff = subPrices(
  { amount: 1000, currency: 'USD' },
  { amount: 5000, currency: 'USD' },
);
// => { amount: -4000, currency: 'USD' }
```

then('they receive a negative amount')
  sothat('debts and deficits can be represented')

---

# usecase.6 = multiply a price

users can multiply a price by a scalar.

aliases: `multiplyPrice`, `priceMultiply`

## given('a user has a price and a multiplier')

### when('the result is exact (no remainder)')

```ts
// with shape
const doubled = multiplyPrice({
  price: { amount: 1000, currency: 'USD' },
  by: 2,
});
// => { amount: 2000, currency: 'USD' }

// with words
const doubled = multiplyPrice({
  price: '$10.00',
  by: 2,
});
// => { amount: 2000, currency: 'USD' }
```

then('they receive the product as IsoPriceShape')

### when('the result has a remainder')

```ts
const result = multiplyPrice({
  price: { amount: 1000, currency: 'USD' },
  by: 1.5,
});
// => { amount: 1500, currency: 'USD' }
```

then('they receive the product as IsoPriceShape')

---

# usecase.7 = divide a price

users can divide a price by a scalar.

aliases: `dividePrice`, `priceDivide`

## given('a user has a price and a divisor')

### when('the result is exact (no remainder)')

```ts
// with shape
const halved = dividePrice({
  price: { amount: 1000, currency: 'USD' },
  by: 2,
});
// => { amount: 500, currency: 'USD' }

// with words
const halved = dividePrice({
  price: '$10.00',
  by: 2,
});
// => { amount: 500, currency: 'USD' }
```

then('they receive the quotient as IsoPriceShape')

### when('the result has a remainder')

```ts
// with shape
const third = dividePrice({
  price: { amount: 1000, currency: 'USD' },
  by: 3,
});
// => { amount: 333, currency: 'USD' }

// with words
const third = dividePrice({
  price: '$10.00',
  by: 3,
});
// => { amount: 333, currency: 'USD' }
```

then('they receive the quotient as IsoPriceShape')

---

# usecase.8 = allocate a price (divide with remainder distribution)

users can split a price into N parts with remainder distribution.

## given('a user wants to split a price fairly')

### when('they allocate via allocatePrice')

```ts
// with shape
const parts = allocatePrice({
  price: { amount: 1000, currency: 'USD' },
  parts: 3,
  remainder: 'first', // explicit remainder option required
});
// => [
//   { amount: 334, currency: 'USD' },
//   { amount: 333, currency: 'USD' },
//   { amount: 333, currency: 'USD' },
// ]

// with words
const parts = allocatePrice({
  price: '$10.00',
  parts: 3,
  remainder: 'first',
});
// => [
//   { amount: 334, currency: 'USD' },
//   { amount: 333, currency: 'USD' },
//   { amount: 333, currency: 'USD' },
// ]
```

then('they receive an array of prices that sum to the original')
  sothat('no pennies are lost in the split')

then('the remainder option is required')
  sothat('users explicitly choose who gets the extra penny')

### when('they allocate by ratios')

```ts
// with shape
const parts = allocatePrice({
  price: { amount: 1000, currency: 'USD' },
  ratios: [1, 1, 2], // 25%, 25%, 50%
  remainder: 'largest',
});
// => [
//   { amount: 250, currency: 'USD' },
//   { amount: 250, currency: 'USD' },
//   { amount: 500, currency: 'USD' },
// ]

// with words
const parts = allocatePrice({
  price: '$10.00',
  ratios: [1, 1, 2],
  remainder: 'largest',
});
// => [
//   { amount: 250, currency: 'USD' },
//   { amount: 250, currency: 'USD' },
//   { amount: 500, currency: 'USD' },
// ]
```

then('they receive parts proportional to the ratios')
  sothat('they can split bills, commissions, etc.')

---

# usecase.9 = support all iso 4217 currencies

users can use any active iso 4217 currency.

## given('a user wants to use a standard currency')

### when('they use a 2-decimal currency (most common)')

```ts
const price = { amount: 50_37, currency: 'USD' }; // $50.37
const price = { amount: 50_37, currency: 'EUR' }; // €50.37
const price = { amount: 50_37, currency: 'GBP' }; // £50.37
```

then('amount is interpreted as 1/100 of the unit')

### when('they use a 0-decimal currency')

```ts
const price = { amount: 1000, currency: 'JPY' }; // ¥1000
const price = { amount: 1000, currency: 'KRW' }; // ₩1000
```

then('amount is interpreted as whole units')

### when('they use a 3-decimal currency')

```ts
const price = { amount: 1_234_567, currency: 'BHD' }; // 1234.567 BHD
const price = { amount: 1_234_567, currency: 'KWD' }; // 1234.567 KWD
```

then('amount is interpreted as 1/1000 of the unit')

---

# usecase.10 = support custom currencies (crypto)

users can define custom currencies not in iso 4217.

## given('a user wants to use a cryptocurrency')

### when('they declare a custom currency')

```ts
const btcPrice = {
  amount: 100_000_000, // 1 BTC in satoshis
  currency: 'BTC',
};

const ethPrice = {
  amount: BigInt('1000000000000000000'), // 1 ETH in wei
  currency: 'ETH',
};
```

then('the price is accepted')
  sothat('users can work with crypto assets')

then('users must handle minor unit conversion themselves')
  sothat('the library does not assume crypto decimals')

---

# usecase.11 = calculate price statistics

users can compute statistical measures across prices.

aliases: `calcPriceStdev`, `priceStdev`

## given('a user has a list of prices in the same currency')

### when('they calculate standard deviation with shapes')

```ts
const stdev = calcPriceStdev([
  { amount: 1000, currency: 'USD' },
  { amount: 2000, currency: 'USD' },
  { amount: 3000, currency: 'USD' },
]);
// => { amount: 816, currency: 'USD' } (approx)
```

then('they receive the standard deviation as IsoPriceShape')
  sothat('they can analyze price distributions')

### when('they calculate standard deviation with words')

```ts
const stdev = calcPriceStdev([
  '$10.00',
  '$20.00',
  '$30.00',
]);
// => { amount: 816, currency: 'USD' } (approx)
```

then('they receive the standard deviation as IsoPriceShape')

---

# boundary cases

## bc.1 = zero price

```ts
const zero: IsoPriceShape<'USD'> = { amount: 0, currency: 'USD' };
sumPrices([zero, zero]); // => { amount: 0, currency: 'USD' }
```

then('zero prices are valid and operate correctly')

## bc.2 = negative price

```ts
const positive: IsoPriceShape<'USD'> = { amount: 1000, currency: 'USD' };
const negative: IsoPriceShape<'USD'> = { amount: -1000, currency: 'USD' }; // -$10.00
sumPrices([positive, negative]); // => { amount: 0, currency: 'USD' }
```

then('negative prices are valid for refunds, debits, etc.')

## bc.3 = very large amounts

```ts
const large: IsoPriceShape<'USD'> = { amount: 999_999_999_999, currency: 'USD' }; // ~$10 billion
sumPrices([large, large]); // should not overflow
```

then('large amounts are handled without overflow')

## bc.4 = empty price list

```ts
sumPrices([]); // error
```

then('an error is thrown for empty lists')
  sothat('users must handle edge cases explicitly')

## bc.5 = single price in list

```ts
sumPrices([{ amount: 1000, currency: 'USD' }]);
// => { amount: 1000, currency: 'USD' }
```

then('single-item lists return the item')

## bc.6 = words format variations

```ts
// symbol prefix
'$50.37'      // USD with cents
'$50'         // USD no cents
'€50.37'      // EUR
'£50.37'      // GBP
'¥1000'       // JPY (no decimals)

// iso code prefix
'USD 50.37'
'EUR 50.37'
'JPY 1000'

// iso code suffix
'50.37 USD'
'50.37 EUR'
'1000 JPY'
```

then('symbol prefix, code prefix, and code suffix formats are all supported')

---

# usecase.12 = high-precision prices (api costs, micro-cents)

users can represent prices with precision beyond standard minor units for usecases like llm api costs and serverless compute costs.

## given('a user wants to track api usage costs')

### when('they declare a per-token llm cost')

```ts
// claude-haiku-3 input: $0.00000025 per token (2.5 nano-dollars)
// note: 25 at exponent 8 = 0.00000025 = 2.5 nano-dollars
const tokenCost: IsoPrice = {
  amount: 250,
  currency: 'USD',
  exponent: 'nano.^-9',
};

// gpt-4o input: $0.000005 per token (5 micro-dollars)
const gpt4Cost: IsoPrice = {
  amount: 5,
  currency: 'USD',
  exponent: 'micro.^-6',
};
```

then('they can represent costs with up to pico precision (12 decimal places)')
  sothat('llm token costs can be tracked precisely')

then('exponent overrides the default iso 4217 minor unit')
  sothat('users can opt-in to higher precision when needed')

### when('they declare a per-invocation serverless cost')

```ts
// aws lambda: $0.000000213 per invocation (213 pico-dollars)
const lambdaCost: IsoPrice = {
  amount: 213,
  currency: 'USD',
  exponent: 'pico.^-12',
};

// aws lambda request: $0.0000002 per request (200 nano-dollars)
const requestCost: IsoPrice = {
  amount: 200,
  currency: 'USD',
  exponent: 'nano.^-9',
};
```

then('they can represent costs at nano-dollar or pico-dollar precision')
  sothat('serverless invocation costs can be tracked precisely')

### when('they sum costs with different precision levels')

```ts
const total = sumPrices([
  { amount: 5037, currency: 'USD' },                              // $50.37 (centi, default)
  { amount: 5, currency: 'USD', exponent: 'micro.^-6' },          // $0.000005
  { amount: 213, currency: 'USD', exponent: 'nano.^-9' },         // $0.000000213
]);
// => { amount: 50_370_005_000_213n, currency: 'USD', exponent: 'nano.^-9' }
// normalized to highest precision
```

then('the result is normalized to the highest precision of all operands')
  sothat('no precision is lost in accumulation')

then('all operands are upscaled to match the highest exponent before arithmetic')
  sothat('integer math preserves accuracy')

### when('they cast high-precision to words')

```ts
const words = asIsoPriceWords({
  price: { amount: 5, currency: 'USD', exponent: 'micro.^-6' },
});
// => '$0.000005'

const words = asIsoPriceWords({
  price: { amount: 213, currency: 'USD', exponent: 'nano.^-9' },
});
// => '$0.000000213'
```

then('all significant digits are preserved in the words format')
  sothat('users can display exact micro-cent values')

### when('they cast words with high precision to shape')

```ts
const shape = asIsoPriceShape('$0.000005');
// => { amount: 5, currency: 'USD', exponent: 'micro.^-6' }

const shape = asIsoPriceShape('$0.000000213');
// => { amount: 213, currency: 'USD', exponent: 'nano.^-9' }
```

then('the minimal exponent that preserves precision is used')
  sothat('shapes are normalized without loss')

## given('a user wants standard precision (default behavior)')

### when('they omit the exponent field')

```ts
const price: IsoPrice = { amount: 5037, currency: 'USD' };
// exponent defaults to 2 (iso 4217 standard for USD)
```

then('the iso 4217 standard exponent is used')
  sothat('most usecases work without explicit exponent')

then('backwards compatibility with standard minor-unit prices is preserved')
  sothat('e-commerce and typical financial usecases work as expected')

---

# usecase.13 = precision levels via declarative exponent type

users declare precision via explicit, self-document exponent strings.

## given('a user wants to declare precision explicitly')

### when('they use the exponent type union')

```ts
// exponent type is a declarative union
type IsoPriceExponent =
  | 'centi.^-2'   // standard cents (USD, EUR, GBP)
  | 'milli.^-3'   // fils (BHD, KWD, OMR)
  | 'micro.^-6'   // micro-dollars (llm token costs)
  | 'nano.^-9'    // nano-dollars (serverless costs)
  | 'pico.^-12';  // pico-dollars (extreme precision)

// amount type supports both number (common cases) and bigint (high precision)
// see ref.dynamic-bigint-usage.md for why both are needed
type IsoPriceShapeAmount = number | bigint;

interface IsoPriceShape {
  amount: IsoPriceShapeAmount;
  currency: string;
  exponent?: IsoPriceExponent;  // optional, defaults to currency standard
}

// example usage - explicit exponent for high precision
const tokenCost: IsoPrice = {
  amount: 5,
  currency: 'USD',
  exponent: 'micro.^-6',
};

const lambdaCost: IsoPrice = {
  amount: 213,
  currency: 'USD',
  exponent: 'nano.^-9',
};

// omit exponent for standard usecases
const price: IsoPrice = { amount: 5037, currency: 'USD' };  // defaults to 'centi.^-2'
const yenPrice: IsoPrice = { amount: 1000, currency: 'JPY' };  // defaults to whole units
const dinarPrice: IsoPrice = { amount: 1234, currency: 'BHD' };  // defaults to 'milli.^-3'
```

then('exponent is optional')
  sothat('standard usecases require no extra configuration')

then('exponent defaults to iso 4217 standard for the currency')
  sothat('USD defaults to centi.^-2, JPY to whole units, BHD to milli.^-3')

then('the exponent string is self-document')
  sothat('reviewers understand both the name and the scale')

then('the `.^-N` suffix makes the math explicit')
  sothat('amount / 10^N is obvious from the type')

### when('they use pico precision')

```ts
// pico precision requires bigint for amount
// reason: $1M in pico-dollars = 10^18, exceeds Number.MAX_SAFE_INTEGER

const picoCost: IsoPrice = {
  amount: 1_000_000_000_000_000_000n, // bigint literal
  currency: 'USD',
  exponent: 'pico.^-12',
};

// type supports both number and bigint via IsoPriceShapeAmount
interface IsoPriceShape<TCurrency extends string = string> {
  amount: IsoPriceShapeAmount;  // bigint required for pico to avoid overflow
  currency: TCurrency;
  exponent?: IsoPriceExponent;
}
```

then('amount accepts bigint')
  sothat('pico-scale precision can represent amounts beyond MAX_SAFE_INTEGER')

then('pico precision can safely represent up to $9 quadrillion')
  sothat('any practical financial amount is supported')

### when('they omit the exponent')

```ts
const price: IsoPrice = { amount: 5037, currency: 'USD' };
// exponent defaults based on iso 4217:
// - USD, EUR, GBP: 'centi.^-2'
// - JPY, KRW: implicit 0 (whole units)
// - BHD, KWD, OMR: 'milli.^-3'
```

then('the iso 4217 standard exponent is inferred from currency')
  sothat('standard usecases require no explicit exponent')

---

# usecase.14 = bigint support for extreme precision

users can use bigint for amounts that exceed javascript safe integer limits.

## given('a user has amounts beyond Number.MAX_SAFE_INTEGER')

### when('they declare a price with bigint amount')

```ts
// Number.MAX_SAFE_INTEGER = 9,007,199,254,740,991

// safe integer ranges by exponent:
// - centi.^-2: up to $90 trillion
// - micro.^-6: up to $9 billion
// - nano.^-9:  up to $9 million
// - pico.^-12: up to $9,007 ← must use bigint beyond this

const largePico: IsoPrice = {
  amount: 1_000_000_000_000_000_000n, // $1M in pico-dollars
  currency: 'USD',
  exponent: 'pico.^-12',
};
```

then('bigint is accepted for amount')
  sothat('pico-scale amounts can represent millions of dollars')

### when('they sum prices with mixed number and bigint')

```ts
const ecommerce: IsoPrice = { amount: 5037, currency: 'USD' };                     // number
const picoApi: IsoPrice = { amount: 213n, currency: 'USD', exponent: 'pico.^-12' }; // bigint

const total = sumPrices([ecommerce, picoApi]);
// => { amount: 5_037_000_000_000_213n, currency: 'USD', exponent: 'pico.^-12' }
// result uses bigint when any operand is bigint
```

then('the result uses bigint when any operand uses bigint')
  sothat('precision is never lost')

### when('they serialize a bigint price to json')

```ts
const price: IsoPrice = { amount: 1_000_000_000_000_000_000n, currency: 'USD', exponent: 'pico.^-12' };

const json = JSON.stringify(asIsoPriceJson(price));
// => '{"amount":"1000000000000000000","currency":"USD","exponent":"pico.^-12"}'
// bigint serialized as string to preserve precision

const restored = asIsoPriceShape(JSON.parse(json));
// => { amount: 1_000_000_000_000_000_000n, currency: 'USD', exponent: 'pico.^-12' }
```

then('bigint amounts are serialized as strings')
  sothat('json round-trip preserves precision')

---

# usecase.15 = set price precision

users can change precision via `setPricePrecision`. when precision decreases, an explicit round mode is required.

aliases: `setPricePrecision`, `roundPrice` (semantic alias for decrease)

## types

```ts
/**
 * .what = round mode for precision decrease
 * .why = makes lossy precision change explicit and auditable
 */
type IsoPriceRoundMode = 'floor' | 'ceil' | 'half-up' | 'half-down' | 'half-even';
```

## given('a user wants to increase precision')

### when('they use setPricePrecision to increase precision')

```ts
// increase precision (lossless) — no mode needed
const highPrecision = setPricePrecision({
  price: { amount: 5037, currency: 'USD', exponent: 'centi.^-2' },
  to: 'micro.^-6',
});
// => { amount: 50_370_000, currency: 'USD', exponent: 'micro.^-6' }
// = $50.37 (same value, higher precision)
```

then('precision increases without loss')
  sothat('prices can be upscaled for arithmetic or storage')

then('no mode is required for precision increase')
  sothat('lossless operations have no round decision')

## given('a user wants to decrease precision')

### when('they use setPricePrecision with a round mode')

```ts
// api costs accumulated at nano precision
const total: IsoPrice = {
  amount: 50_370_005_213n,
  currency: 'USD',
  exponent: 'nano.^-9',
};
// = $50.370005213

// decrease to cents for invoice — mode required
const rounded = setPricePrecision({
  price: total,
  to: 'centi.^-2',
  with: { round: 'half-up' },
});
// => { amount: 5037, currency: 'USD', exponent: 'centi.^-2' }
// = $50.37
```

then('they receive a price at the target exponent')
  sothat('they can reduce precision for display, storage, or invoice')

then('mode is required for precision decrease')
  sothat('users explicitly choose how remainders are handled')

### when('they use different round modes')

```ts
const price: IsoPrice = { amount: 5555, currency: 'USD', exponent: 'milli.^-3' };
// = $5.555

// floor: always round toward negative infinity
setPricePrecision({ price, to: 'centi.^-2' }, { round: 'floor' } });
// => { amount: 555, currency: 'USD', exponent: 'centi.^-2' }
// = $5.55

// ceil: always round toward positive infinity
setPricePrecision({ price, to: 'centi.^-2' }, { round: 'ceil' } });
// => { amount: 556, currency: 'USD', exponent: 'centi.^-2' }
// = $5.56

// half-up: round half away from zero (standard)
setPricePrecision({ price, to: 'centi.^-2' }, { round: 'half-up' } });
// => { amount: 556, currency: 'USD', exponent: 'centi.^-2' }
// = $5.56

// half-down: round half toward zero
setPricePrecision({ price, to: 'centi.^-2' }, { round: 'half-down' } });
// => { amount: 555, currency: 'USD', exponent: 'centi.^-2' }
// = $5.55

// half-even: round half to nearest even (banker's round)
setPricePrecision({ price, to: 'centi.^-2' }, { round: 'half-even' } });
// => { amount: 556, currency: 'USD', exponent: 'centi.^-2' }
// = $5.56 (6 is even)

// another half-even example
const price2: IsoPrice = { amount: 5545, currency: 'USD', exponent: 'milli.^-3' };
setPricePrecision({ of: price2, to: 'centi.^-2' }, { round: 'half-even' } });
// => { amount: 554, currency: 'USD', exponent: 'centi.^-2' }
// = $5.54 (4 is even)
```

then('each mode handles the remainder differently')
  sothat('users can match their domain requirements')

then('half-even (banker\'s round) minimizes cumulative bias')
  sothat('financial aggregations remain fair')

### when('they decrease precision without a mode')

```ts
// error: precision decrease requires mode
setPricePrecision({
  price: { amount: 50370021, currency: 'USD', exponent: 'micro.^-6' },
  to: 'centi.^-2',
  // no `with: { round }` — error
});
// => error: precision decrease requires `with: { round }`
```

then('an error is thrown')
  sothat('lossy operations are never implicit')

## given('roundPrice as semantic alias')

### when('they use roundPrice for explicit decrease intent')

```ts
/**
 * .what = semantic alias for precision decrease
 * .why = clearer intent when precision loss is expected
 */
const roundPrice = (input: {
  of: IsoPrice;
  to: IsoPriceExponent;
  mode?: IsoPriceRoundMode;  // defaults to 'half-up'
}) => setPricePrecision({
  price: input.of,
  to: input.to,
  with: { round: input.mode ?? 'half-up' },
});

// usage
const rounded = roundPrice({
  of: '$50.375',
  to: 'centi.^-2',
});  // mode defaults to 'half-up'
// => { amount: 5038, currency: 'USD', exponent: 'centi.^-2' }
// = $50.38
```

then('roundPrice delegates to setPricePrecision')
  sothat('there is one implementation, two semantic entry points')

then('roundPrice defaults mode to half-up')
  sothat('the most common round mode is the default for convenience')

---

# usecase.16 = llm api token cost computation

users can track llm api costs from per-token prices through aggregated totals, with full support for both small and large token counts.

## given('a user wants to track llm api token costs')

### when('they declare a per-token price in IsoPriceWords format')

```ts
// claude-3.5-sonnet input: $0.000003 per token (3 micro-dollars)
const sonnetInputCost: IsoPrice = isIsoPriceWords.assure('$0.000003');

// claude-3.5-sonnet output: $0.000015 per token (15 micro-dollars)
const sonnetOutputCost: IsoPrice = isIsoPriceWords.assure('$0.000015');

// gpt-4o input: $0.0000025 per token (2.5 micro-dollars = 2500 nano-dollars)
const gpt4oInputCost: IsoPrice = isIsoPriceWords.assure('$0.0000025');
```

then('the words format preserves all significant digits')
  sothat('sub-cent prices can be declared in human-readable form')

### when('they declare a per-token price in IsoPriceShape format')

```ts
// claude-3.5-sonnet input: $0.000003 per token
const sonnetInputCost: IsoPrice = {
  amount: 3,
  currency: 'USD',
  exponent: 'micro.^-6',
};

// claude-3.5-sonnet output: $0.000015 per token
const sonnetOutputCost: IsoPrice = {
  amount: 15,
  currency: 'USD',
  exponent: 'micro.^-6',
};

// gpt-4o input: $0.0000025 per token (2500 nano-dollars)
const gpt4oInputCost: IsoPrice = {
  amount: 2500,
  currency: 'USD',
  exponent: 'nano.^-9',
};
```

then('the shape format uses integer amounts with explicit exponents')
  sothat('no float precision issues occur')

then('both formats represent the same price')
  sothat('users can choose whichever is more convenient')

### when('they compute cost for token counts within safe integer range')

```ts
// 1 million input tokens at $0.000003/token
const tokenCount = 1_000_000;
const perTokenCost: IsoPrice = { amount: 3, currency: 'USD', exponent: 'micro.^-6' };

const totalCost = multiplyPrice({ of: perTokenCost, by: tokenCount });
// => { amount: 3_000_000, currency: 'USD', exponent: 'micro.^-6' }
// = $3.00

// 100 million tokens: still within safe integer range at micro precision
const largeBatch = multiplyPrice({ of: perTokenCost, by: 100_000_000 });
// => { amount: 300_000_000, currency: 'USD', exponent: 'micro.^-6' }
// = $300.00
```

then('standard number arithmetic is used')
  sothat('common usecases have no overhead')

### when('they compute cost for token counts beyond safe integer range')

```ts
// Number.MAX_SAFE_INTEGER = 9,007,199,254,740,991
// at micro.^-6, this represents ~$9 billion — plenty for most usecases

// but at nano.^-9 precision, safe range is only ~$9 million
// for aggregated platform costs, bigint may be needed

// 10 billion tokens at nano precision: $0.0000025/token = 2500 nano-dollars
const platformTokens = 10_000_000_000n; // 10 billion
const perTokenNano: IsoPrice = { amount: 2500n, currency: 'USD', exponent: 'nano.^-9' };

const platformCost = multiplyPrice({ of: perTokenNano, by: platformTokens });
// => { amount: 25_000_000_000_000_000n, currency: 'USD', exponent: 'nano.^-9' }
// = $25,000,000.00 (25 million dollars)
```

then('bigint arithmetic is used when operands are bigint')
  sothat('platform-scale aggregations work without overflow')

### when('they console.log a bigint price')

```ts
const platformCost: IsoPrice = {
  amount: 25_000_000_000_000_000n,
  currency: 'USD',
  exponent: 'nano.^-9',
};

console.log(platformCost);
// => { amount: 25000000000000000n, currency: 'USD', exponent: 'nano.^-9' }

console.log(asIsoPriceWords(platformCost));
// => '$25000000.00'
```
.agent/repo=.this/role=dbadmin/briefs/per001.isoprice.persistence._.[article].md
then('bigint amounts display correctly in console output')
  sothat('developers can debug and inspect values')

### when('they JSON.stringify a bigint price')

```ts
const platformCost: IsoPrice = {
  amount: 25_000_000_000_000_000n,
  currency: 'USD',
  exponent: 'nano.^-9',
};

// direct stringify would fail: TypeError: BigInt can not be serialized in JSON
// use asIsoPriceJson for safe serialization
const json = JSON.stringify(asIsoPriceJson(platformCost));
// => '{"amount":"25000000000000000","currency":"USD","exponent":"nano.^-9"}'

// round-trip back to IsoPrice
const restored = asIsoPriceShape(JSON.parse(json));
// => { amount: 25_000_000_000_000_000n, currency: 'USD', exponent: 'nano.^-9' }
```

then('asIsoPriceJson serializes bigint as string')
  sothat('json round-trip preserves precision')

then('asIsoPriceShape restores bigint from string representation')
  sothat('deserialized prices are ready for arithmetic')

### when('they accumulate costs from mixed precision sources')

```ts
// aggregate costs from different llm providers
const costs: IsoPrice[] = [
  // claude api: 50M tokens at $0.000003 = $150
  { amount: 150_000_000, currency: 'USD', exponent: 'micro.^-6' },

  // openai api: 30M tokens at $0.0000025 = $75
  { amount: 75_000_000_000, currency: 'USD', exponent: 'nano.^-9' },

  // text-embed api: 200M tokens at $0.00000013 = $26
  { amount: 26_000_000_000, currency: 'USD', exponent: 'nano.^-9' },
];

const totalCost = sumPrices(costs);
// => { amount: 251_000_000_000, currency: 'USD', exponent: 'nano.^-9' }
// = $251.00

// round to standard cents for invoice
const invoiceAmount = roundPrice({ of: totalCost, to: 'centi.^-2' });
// => { amount: 25100, currency: 'USD', exponent: 'centi.^-2' }
// = $251.00
```

then('prices normalize to highest precision before sum')
  sothat('no precision is lost in aggregation')

then('results can be rounded for display or invoice')
  sothat('users control final precision explicitly')

