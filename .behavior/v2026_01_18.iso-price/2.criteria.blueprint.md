# blueprint criteria = iso-price

mechanism bounds to deliver the blackbox experience.

---

## blackbox criteria satisfied

- c.1 = format.words ✓
- c.1b = format.human ✓
- c.2 = format.shape ✓
- c.2b = format.shape.constraints ✓
- c.3 = cast ✓
- c.4 = arithmetic.sum ✓
- c.5 = arithmetic.sub ✓
- c.6 = arithmetic.mul ✓
- c.7 = arithmetic.div ✓
- c.8 = arithmetic.allocate ✓
- c.9 = precision.change ✓
- c.10 = precision.round ✓
- c.11 = precision.roundPrice ✓
- c.12 = amount.bigint ✓
- c.13 = serialize ✓
- c.14 = currency.iso4217 ✓
- c.15 = currency.custom ✓
- c.16 = statistics ✓
- c.17 = currency.constraint ✓

---

## subcomponent contracts

### types

given('IsoPriceWords type contract')
  then('is a branded template literal: `${TCurrency} ${string}`')
  then('TCurrency defaults to string for backwards compat')
  then('passes type guard isIsoPriceWords')

given('IsoPriceHuman type contract')
  then('is a branded string for symbol format')
  then('passes type guard isIsoPriceHuman')

given('IsoPriceShape type contract')
  then('has amount: bigint (always bigint, never number)')
  then('has currency: TCurrency')
  then('has exponent?: TExponent (optional, defaults to currency standard)')
  then('TCurrency and TExponent are constrainable via generics')

given('IsoPrice type contract')
  then('is union: IsoPriceWords | IsoPriceShape | IsoPriceHuman')
  then('operations accept any variant as input')

given('IsoCurrency enum contract')
  then('exports top ~25 currencies by trade volume')
  then('exports 4 currencies with 3-decimal exponent (BHD, KWD, OMR, TND)')
  then('usable at compile-time (type constraint) and runtime (iteration)')

given('IsoPriceExponent type contract')
  then('is union of: whole.x10^0 | centi.x10^-2 | milli.x10^-3 | micro.x10^-6 | nano.x10^-9 | pico.x10^-12')

given('IsoPriceRoundMode type contract')
  then('is union of: floor | ceil | half-up | half-down | half-even')

### cast functions

given('asIsoPrice contract')
  then('accepts: IsoPrice | string (human format)')
  then('returns: IsoPriceWords')
  then('normalizes symbol input to code-prefix format')
  then('normalizes comma separators to underscores')
  then('accepts { currency } option to override symbol default')
  then('throws on symbol/currency mismatch')

given('asIsoPriceWords contract')
  then('accepts: IsoPrice')
  then('returns: IsoPriceWords')

given('asIsoPriceShape contract')
  then('accepts: IsoPrice')
  then('accepts: { amount: number | bigint, currency, exponent? }')
  then('returns: IsoPriceShape with amount as bigint')

given('asIsoPriceHuman contract')
  then('accepts: IsoPrice')
  then('returns: IsoPriceHuman (symbol format)')

given('isIsoPriceWords contract')
  then('accepts: unknown')
  then('returns: boolean type guard')
  then('exposes .assure() for fail-fast validation')

given('isIsoPriceShape contract')
  then('accepts: unknown')
  then('returns: boolean type guard')

given('isIsoPriceHuman contract')
  then('accepts: unknown')
  then('returns: boolean type guard')

given('isIsoPrice contract')
  then('accepts: unknown')
  then('returns: true if isIsoPriceWords || isIsoPriceShape || isIsoPriceHuman')

### arithmetic operations

given('sumPrices contract')
  then('accepts: spread syntax (...prices: IsoPrice[])')
  then('accepts: array syntax ([prices], options?)')
  then('returns: IsoPriceWords by default')
  then('returns: IsoPriceShape when { format: "shape" }')
  then('normalizes to highest precision before sum')
  then('throws on currency mismatch')
  then('requires at least 1 argument (compile-time)')

given('subPrices contract')
  then('accepts: spread syntax (...prices: IsoPrice[])')
  then('accepts: array syntax ([prices], options?)')
  then('returns: IsoPriceWords by default')
  then('returns: IsoPriceShape when { format: "shape" }')
  then('allows negative results')
  then('throws on currency mismatch')

given('multiplyPrice contract')
  then('accepts: { of: IsoPrice, by: number }')
  then('accepts: options { round?: IsoPriceRoundMode, format?: "words" | "shape" }')
  then('returns: IsoPriceWords by default')
  then('rounds to input precision (half-up by default)')
  then('preserves input exponent in output')

given('dividePrice contract')
  then('accepts: { of: IsoPrice, by: number }')
  then('accepts: options { round?: IsoPriceRoundMode, format?: "words" | "shape" }')
  then('returns: IsoPriceWords by default')
  then('rounds to input precision (half-up by default)')
  then('preserves input exponent in output')

given('allocatePrice contract')
  then('accepts: { of: IsoPrice, into: { parts: number } | { ratios: number[] }, remainder: "first" | "last" | "largest" | "random" }')
  then('accepts: options { format?: "words" | "shape" }')
  then('returns: IsoPriceWords[] by default')
  then('sum of returned parts === input (lossless)')
  then('distributes remainder per strategy')

### precision operations

given('setPricePrecision contract')
  then('accepts: { of: IsoPrice, to: IsoPriceExponent }')
  then('accepts: options { round?: IsoPriceRoundMode, format?: "words" | "shape" }')
  then('returns: IsoPriceWords by default')
  then('increase precision: lossless, no round needed')
  then('decrease precision: lossy, defaults to half-up')

given('roundPrice contract')
  then('accepts: { of: IsoPrice, to: IsoPriceExponent, mode?: IsoPriceRoundMode }')
  then('returns: IsoPriceWords')
  then('is semantic alias for setPricePrecision with half-up default')

given('getIsoPriceExponentByCurrency contract')
  then('accepts: string (currency code)')
  then('returns: IsoPriceExponent')
  then('defaults to centi.x10^-2 for unknown currencies')
  then('returns whole.x10^0 for JPY, KRW')
  then('returns milli.x10^-3 for BHD, KWD, OMR, TND')

### statistics

given('calcPriceStdev contract')
  then('accepts: spread syntax (...prices: IsoPrice[])')
  then('accepts: array syntax ([prices], options?)')
  then('returns: IsoPriceWords by default')
  then('returns: IsoPriceShape when { format: "shape" }')

---

## composition boundaries

given('cast functions')
  then('form the foundation layer — all other operations use casts internally')
  then('asIsoPriceShape is the internal representation for arithmetic')
  then('asIsoPriceWords is the default output format')

given('arithmetic operations')
  then('accept any IsoPrice variant via cast layer')
  then('perform computation on IsoPriceShape internally')
  then('return IsoPriceWords by default, IsoPriceShape when { format: "shape" }')

given('precision operations')
  then('compose with arithmetic operations (multiply/divide by power of 10)')
  then('round operations use bigint division with remainder handle')

given('allocatePrice')
  then('composes precision normalization + remainder distribution')
  then('does not depend on dividePrice (different algorithm)')

---

## integration boundaries

given('json serialization boundary')
  then('IsoPriceWords serializes directly (string)')
  then('IsoPriceShape requires conversion to words before JSON.stringify')

given('database boundary')
  then('IsoPriceWords persists to TEXT or custom iso_price_words domain')
  then('IsoPriceShape can persist to composite type or 3-column pattern')

given('stripe api boundary')
  then('asIsoPriceShape().amount provides integer cents for stripe')
  then('currency codes align with stripe expectations')

---

## test coverage criteria

given('type definitions')
  then('has compile-time tests for generic constraints')
  then('has compile-time tests for type guard narrow')

given('cast functions')
  then('has unit tests for each input variant')
  then('has unit tests for edge cases: zero, negative, high precision')
  then('has unit tests for error cases: invalid input, symbol/currency mismatch')

given('arithmetic operations')
  then('has unit tests for spread syntax and array syntax')
  then('has unit tests for mixed precision inputs')
  then('has unit tests for round mode options')
  then('has unit tests for format options')
  then('has unit tests for currency mismatch errors')

given('allocatePrice')
  then('has unit tests for equal parts distribution')
  then('has unit tests for ratio distribution')
  then('has unit tests for each remainder strategy')
  then('has unit tests that prove sum === input (lossless invariant)')

given('precision operations')
  then('has unit tests for increase precision (lossless)')
  then('has unit tests for decrease precision (each round mode)')

given('full experience')
  then('has acceptance test for vision.experience.1 (llm cost forward)')
  then('acceptance test covers: track → accumulate → markup → round → invoice')
