# blackbox criteria = iso-price (v2)

orthogonal, disjoint criteria for the iso-price package.

---

# types

```ts
type IsoPrice = IsoPriceWords | IsoPriceShape | IsoPriceHuman;

/**
 * code-prefix format with numeric separators (e.g., 'USD 1_000.50')
 * - unambiguous: currency code is explicit
 * - readable: underscore thousands separator (ES2021 style)
 * - valid for input AND output
 * - TCurrency: constrain to specific currencies (default: any string)
 */
type IsoPriceWords<TCurrency extends string = string> =
  `${TCurrency} ${string}` & { __brand: 'IsoPriceWords' };

/**
 * symbol format (e.g., '$50.37')
 * - valid for input: defaults to common currency ($ = USD, € = EUR, etc.)
 * - valid for output: use asIsoPriceHuman() to produce
 * - currency override via options: { currency: 'CAD' }
 */
type IsoPriceHuman = string & { __brand: 'IsoPriceHuman' };

/**
 * structured price object with constrainable currency and exponent
 * - TCurrency: constrain to specific currencies (default: any string)
 * - TExponent: constrain to specific precision levels (default: any exponent)
 */
interface IsoPriceShape<
  TCurrency extends string = string,
  TExponent extends IsoPriceExponent = IsoPriceExponent,
> {
  amount: bigint;  // always bigint — cast functions accept number and convert
  currency: TCurrency;
  exponent?: TExponent;
}

/**
 * known ISO 4217 currencies (top ~25 by trade volume + 3-decimal currencies)
 * - use for type-safe currency constraints
 * - use as runtime enum for selection and iteration
 * - custom currencies (BTC, ETH) still work via string
 */
enum IsoCurrency {
  USD = 'USD', EUR = 'EUR', JPY = 'JPY', GBP = 'GBP', CNY = 'CNY',
  AUD = 'AUD', CAD = 'CAD', CHF = 'CHF', HKD = 'HKD', NZD = 'NZD',
  SEK = 'SEK', KRW = 'KRW', SGD = 'SGD', NOK = 'NOK', MXN = 'MXN',
  INR = 'INR', ZAR = 'ZAR', BRL = 'BRL', DKK = 'DKK', PLN = 'PLN',
  THB = 'THB', BHD = 'BHD', KWD = 'KWD', OMR = 'OMR', TND = 'TND',
}

/**
 * lookup the standard exponent for a currency
 * - defaults to 'centi.x10^-2' (most currencies)
 * - overrides for 0-decimal (JPY, KRW) and 3-decimal (BHD, KWD, OMR, TND)
 */
const getIsoPriceExponentByCurrency = (currency: string): IsoPriceExponent => {
  const overrides: Partial<Record<string, IsoPriceExponent>> = {
    // 0-decimal currencies
    JPY: 'whole.x10^0',
    KRW: 'whole.x10^0',

    // 3-decimal currencies
    BHD: 'milli.x10^-3',
    KWD: 'milli.x10^-3',
    OMR: 'milli.x10^-3',
    TND: 'milli.x10^-3',
  };
  return overrides[currency] ?? 'centi.x10^-2';
};

type IsoPriceExponent =
  | 'whole.x10^0'    // 10^0: whole units (JPY, KRW)
  | 'centi.x10^-2'   // 10^-2: standard cents
  | 'milli.x10^-3'   // 10^-3: fils (BHD, KWD)
  | 'micro.x10^-6'   // 10^-6: llm token costs
  | 'nano.x10^-9'    // 10^-9: serverless costs
  | 'pico.x10^-12';  // 10^-12: extreme precision

type IsoPriceRoundMode = 'floor' | 'ceil' | 'half-up' | 'half-down' | 'half-even';
```

---

# criteria

## c.1 = format.words

IsoPriceWords is a branded string in **code-prefix format only** (e.g., `'USD 50.37'`).

- underscore thousands separator — numeric separator notation (ES2021)
- no symbols — unambiguous currency code only
- decimal point (`.`) — scientific notation, no locale ambiguity

```ts
// valid format: code prefix, underscore separators
'USD 50.37'           // us dollar
'EUR 50.37'           // euro
'JPY 1_000'           // yen (no decimals)
'USD 0.000_003'       // high precision (micro-dollars)
'USD 1_000_000.00'    // one million — underscores for readability

// invalid IsoPriceWords: commas not allowed
isIsoPriceWords('USD 1,000,000.00')  // => false

// but asIsoPrice accepts commas as convenience input
asIsoPrice('USD 1,000,000.00')       // => 'USD 1_000_000.00' (normalized to underscores)

// validation
isIsoPriceWords('USD 50.37')    // => true
isIsoPriceWords('$50.37')       // => false — symbols not allowed
isIsoPriceWords('fifty bucks')  // => false
isIsoPriceWords.assure('USD 50.37') // => 'USD 50.37' as IsoPriceWords (or throws)
```

## c.1b = format.human

IsoPriceHuman is a branded string with symbol format. valid for **input and output**.

- commas supported — human-readable display
- symbols supported — `$`, `€`, `£`, `¥`, etc.

```ts
// input: symbols default to common currency
asIsoPrice('$50.37')              // => 'USD 50.37' ($ defaults to USD)
asIsoPrice('€50.37')              // => 'EUR 50.37' (€ defaults to EUR)
asIsoPrice('¥1000')               // => 'JPY 1_000'  (¥ defaults to JPY)
asIsoPrice('$1,000,000.00')       // => 'USD 1_000_000.00' (normalized to underscores)

// input: override currency via options
asIsoPrice('$50.37', { currency: 'CAD' })  // => 'CAD 50.37'
asIsoPrice('$50.37', { currency: 'AUD' })  // => 'AUD 50.37'

// output: produce symbol format via asIsoPriceHuman()
asIsoPriceHuman('USD 50.37')          // => '$50.37'
asIsoPriceHuman('EUR 50.37')          // => '€50.37'
asIsoPriceHuman('JPY 1_000')          // => '¥1,000'
asIsoPriceHuman('USD 1_000_000.00')   // => '$1,000,000.00' (locale commas)

// validation
isIsoPriceHuman('$50.37')  // => true
isIsoPriceHuman('50.37')   // => false — no symbol

// failfast: symbol + currency mismatch
asIsoPrice('€50.37', { currency: 'USD' })  // => error: symbol € does not match currency USD
asIsoPrice('$50.37', { currency: 'EUR' })  // => error: symbol $ does not match currency EUR
```

symbol defaults:
| symbol | default currency |
| ------ | ---------------- |
| $      | USD              |
| €      | EUR              |
| £      | GBP              |
| ¥      | JPY              |
| ₩      | KRW              |

note: symbols remain lossy compression — for unambiguous storage, use `IsoPriceWords`.

## c.2 = format.shape

IsoPriceShape is a structured object with **bigint** amount, currency, and optional exponent.

```ts
// standard precision (exponent defaults to iso 4217)
{ amount: 5037n, currency: 'USD' }           // $50.37 (centi.x10^-2 default)
{ amount: 1000n, currency: 'JPY' }           // ¥1000 (no decimals)
{ amount: 1234n, currency: 'BHD' }           // 1.234 BHD (milli.x10^-3 default)

// explicit exponent for high precision
{ amount: 3n, currency: 'USD', exponent: 'micro.x10^-6' }  // $0.000003

// validation
isIsoPriceShape({ amount: 5037n, currency: 'USD' }) // => true
isIsoPriceShape('$50.37')                           // => false
```

note: cast functions accept `number` and convert to `bigint` for convenience:

```ts
asIsoPriceShape('USD 50.37')
// => { amount: 5037n, currency: 'USD' }

asIsoPriceShape({ amount: 5037, currency: 'USD' })  // number input accepted
// => { amount: 5037n, currency: 'USD' }            // bigint output
```

## c.2b = format.shape.constraints

IsoPriceShape supports **type-level constraints** via generic parameters for currency and exponent.

```ts
// loose — any currency, any exponent (default)
const price: IsoPriceShape = { amount: 5037n, currency: 'USD' };

// constrained currency — only known ISO 4217 codes
const isoPrice: IsoPriceShape<IsoCurrency> = { amount: 5037n, currency: 'USD' };
const badIso: IsoPriceShape<IsoCurrency> = { amount: 100n, currency: 'BTC' };  // ✗ compile error

// constrained exponent — must be cents
const centPrice: IsoPriceShape<string, 'centi.x10^-2'> = {
  amount: 5037n,
  currency: 'USD',
  exponent: 'centi.x10^-2',
};
const badExp: IsoPriceShape<string, 'centi.x10^-2'> = {
  amount: 5n,
  currency: 'USD',
  exponent: 'micro.x10^-6',  // ✗ compile error
};

// fully constrained — USD cents only
const usdCents: IsoPriceShape<'USD', 'centi.x10^-2'> = {
  amount: 5037n,
  currency: 'USD',
};

// custom currency still works with string
const btcPrice: IsoPriceShape<'BTC'> = { amount: 100_000_000n, currency: 'BTC' };
const ethPrice: IsoPriceShape<'ETH'> = { amount: 1_000_000_000_000_000_000n, currency: 'ETH' };
```

use cases:
- **e-commerce**: `IsoPriceShape<IsoCurrency, 'centi.x10^-2'>` — standard currencies, cents only
- **crypto**: `IsoPriceShape<'BTC' | 'ETH'>` — custom currency codes
- **micro-prices**: `IsoPriceShape<'USD', 'micro.x10^-6'>` — USD at micro-dollar precision
- **multi-currency**: `IsoPriceShape<'USD' | 'EUR' | 'GBP'>` — specific currency subset

enum for runtime selection and iteration:

```ts
import { IsoCurrency } from 'iso-price';

// use enum value
const price: IsoPriceShape<IsoCurrency> = {
  amount: 5037n,
  currency: IsoCurrency.USD,
};

// iterate over known currencies
Object.values(IsoCurrency).forEach(currency => {
  console.log(currency);  // 'USD', 'EUR', 'JPY', ...
});

// use in runtime checks
if (Object.values(IsoCurrency).includes(input.currency)) {
  // known ISO 4217 currency
}
```

## c.3 = cast

Convert between formats via cast functions. Cast functions accept `number` input and return `bigint` output.

```ts
// from human (symbol format)
asIsoPrice('$50.37')                        // => 'USD 50.37'
asIsoPrice('$50.37', { currency: 'CAD' })   // => 'CAD 50.37'
asIsoPriceShape('$5')                       // => { amount: 500n, currency: 'USD' }

// from words (code-prefix format)
asIsoPriceShape('USD 50.37')
// => { amount: 5037n, currency: 'USD' }

asIsoPriceShape('USD 0.000003')
// => { amount: 3n, currency: 'USD', exponent: 'micro.x10^-6' }

// to words (code-prefix format)
asIsoPriceWords({ amount: 5037n, currency: 'USD' })
// => 'USD 50.37'

asIsoPriceWords({ amount: 3n, currency: 'USD', exponent: 'micro.x10^-6' })
// => 'USD 0.000003'

// to human (symbol format)
asIsoPriceHuman('USD 50.37')
// => '$50.37'

asIsoPriceHuman('EUR 50.37')
// => '€50.37'
```

note: for json persistence, use `IsoPriceWords` — it serializes trivially and is portable.

## c.4 = arithmetic.sum

Sum prices of the same currency.

```ts
// spread syntax (recommended)
sumPrices('USD 10.00', 'USD 20.00')
// => 'USD 30.00'

// array syntax (required when options needed)
sumPrices(['USD 10.00', 'USD 20.00'], { format: 'shape' })
// => { amount: 3000n, currency: 'USD' }

// also accepts shape input (number converted to bigint internally)
sumPrices({ amount: 1000, currency: 'USD' }, { amount: 2000, currency: 'USD' })
// => 'USD 30.00'

// mixed exponents normalize to highest precision
sumPrices('USD 50.37', 'USD 0.000005')
// => 'USD 50.370005'

// currency mismatch: error
sumPrices('USD 10.00', 'EUR 20.00')  // => error
```

## c.5 = arithmetic.sub

Subtract prices of the same currency.

```ts
// spread syntax (recommended)
subPrices('USD 50.00', 'USD 20.00')
// => 'USD 30.00'

// negative results allowed (for refunds, debits)
subPrices('USD 10.00', 'USD 50.00')
// => 'USD -40.00'

// array syntax (required when options needed)
subPrices(['USD 50.00', 'USD 20.00'], { format: 'shape' })
// => { amount: 3000n, currency: 'USD' }
```

## c.6 = arithmetic.mul

Multiply a price by a scalar. Result rounds to input precision (half-up by default).

jsdoc must include:
```ts
/**
 * multiply a price by a scalar
 *
 * result rounds to input precision (half-up by default). pass `{ round }` to
 * override. for lossless distribution across recipients, use `allocatePrice`.
 *
 * @example multiplyPrice({ of: 'USD 100.00', by: 1.08 }) // => 'USD 108.00'
 */
```

```ts
// scale up (e.g., tax markup)
multiplyPrice({ of: 'USD 100.00', by: 1.08 })
// => 'USD 108.00'

// scale down (e.g., discount)
multiplyPrice({ of: 'USD 100.00', by: 0.90 })
// => 'USD 90.00'

// rounds to input precision (centi.x10^-2 in, centi.x10^-2 out)
multiplyPrice({ of: 'USD 10.00', by: 0.333 })
// => 'USD 3.33' (not 'USD 3.330')

// high-precision input preserves precision
multiplyPrice({ of: 'USD 0.000_001', by: 7 })
// => 'USD 0.000_007'

// shape output when needed
multiplyPrice({ of: 'USD 10.00', by: 3 }, { format: 'shape' })
// => { amount: 3000n, currency: 'USD' }

// explicit round mode
multiplyPrice({ of: 'USD 10.00', by: 0.333 }, { round: 'floor' })
// => 'USD 3.33'

multiplyPrice({ of: 'USD 10.00', by: 0.336 }, { round: 'ceil' })
// => 'USD 3.37'
```

## c.7 = arithmetic.div

Divide a price by a scalar. Result rounds to input precision (half-up by default).

jsdoc must include:
```ts
/**
 * divide a price by a scalar
 *
 * result rounds to input precision (half-up by default). pass `{ round }` to
 * override. remainder is lost — for lossless distribution across recipients,
 * use `allocatePrice`.
 *
 * @example dividePrice({ of: 'USD 10.00', by: 4 }) // => 'USD 2.50'
 */
```

```ts
// even division
dividePrice({ of: 'USD 10.00', by: 4 })
// => 'USD 2.50'

// rounds to input precision (centi.x10^-2 in, centi.x10^-2 out)
dividePrice({ of: 'USD 10.00', by: 3 })
// => 'USD 3.33' (remainder lost — use allocatePrice for fair distribution)

// high-precision input preserves precision
dividePrice({ of: 'USD 0.000_021', by: 3 })
// => 'USD 0.000_007'

// shape output when needed
dividePrice({ of: 'USD 10.00', by: 4 }, { format: 'shape' })
// => { amount: 250n, currency: 'USD' }

// explicit round mode
dividePrice({ of: 'USD 10.00', by: 3 }, { round: 'floor' })
// => 'USD 3.33'

dividePrice({ of: 'USD 10.00', by: 3 }, { round: 'ceil' })
// => 'USD 3.34'
```

## c.8 = arithmetic.allocate

Split a price into parts with remainder distribution. Sum of parts always equals input (lossless).

jsdoc must include:
```ts
/**
 * allocate a price across recipients without loss
 *
 * unlike `dividePrice`, the sum of allocated parts always equals the original
 * amount. use this when you need to distribute funds fairly (bill split, tip
 * pool, tax allocation, payroll, etc.).
 *
 * @example allocatePrice({ of: 'USD 10.00', into: { parts: 3 }, remainder: 'first' })
 *          // => ['USD 3.34', 'USD 3.33', 'USD 3.33'] (sum = $10.00)
 */
```

```ts
// words format (recommended) — equal parts
allocatePrice({ of: 'USD 10.00', into: { parts: 3 }, remainder: 'first' })
// => ['USD 3.34', 'USD 3.33', 'USD 3.33']

// by ratios
allocatePrice({ of: 'USD 10.00', into: { ratios: [1, 1, 2] }, remainder: 'largest' })
// => ['USD 2.50', 'USD 2.50', 'USD 5.00']

// shape output when needed
allocatePrice({ of: 'USD 10.00', into: { parts: 3 }, remainder: 'first' }, { format: 'shape' })
// => [{ amount: 334n }, { amount: 333n }, { amount: 333n }]
```

## c.9 = precision.change

Change precision via setPricePrecision. Decrease defaults to `round: 'half-up'`.

```ts
// increase: lossless
setPricePrecision({ of: 'USD 50.37', to: 'micro.x10^-6' })
// => 'USD 50.370_000'

// decrease: lossy, defaults to half-up
setPricePrecision({ of: 'USD 50.370_005', to: 'centi.x10^-2' })
// => 'USD 50.37'

// decrease with explicit round mode
setPricePrecision({ of: 'USD 50.370_005', to: 'centi.x10^-2' }, { round: 'floor' })
// => 'USD 50.37'

// shape output when needed
setPricePrecision({ of: 'USD 50.37', to: 'micro.x10^-6' }, { format: 'shape' })
// => { amount: 50_370_000n, currency: 'USD', exponent: 'micro.x10^-6' }
```

## c.10 = precision.round

Round modes for precision decrease. Default is `half-up`.

```ts
setPricePrecision({ of: 'USD 5.555', to: 'centi.x10^-2' })                         // => 'USD 5.56' (default: half-up)
setPricePrecision({ of: 'USD 5.555', to: 'centi.x10^-2' }, { round: 'floor' })     // => 'USD 5.55'
setPricePrecision({ of: 'USD 5.555', to: 'centi.x10^-2' }, { round: 'ceil' })      // => 'USD 5.56'
setPricePrecision({ of: 'USD 5.555', to: 'centi.x10^-2' }, { round: 'half-up' })   // => 'USD 5.56'
setPricePrecision({ of: 'USD 5.555', to: 'centi.x10^-2' }, { round: 'half-down' }) // => 'USD 5.55'
setPricePrecision({ of: 'USD 5.555', to: 'centi.x10^-2' }, { round: 'half-even' }) // => 'USD 5.56' (6 is even)
```

## c.11 = precision.roundPrice

Semantic alias for precision decrease with half-up default.

```ts
// words format (recommended)
roundPrice({ of: 'USD 50.375', to: 'centi.x10^-2' })
// => 'USD 50.38'

roundPrice({ of: 'USD 50.374', to: 'centi.x10^-2' })
// => 'USD 50.37'

// explicit mode
roundPrice({ of: 'USD 50.375', to: 'centi.x10^-2', mode: 'floor' })
// => 'USD 50.37'
```

## c.12 = amount.bigint

`IsoPriceShape.amount` is always `bigint` for unlimited precision. no mixed-mode complexity.

```ts
// words format (recommended) — bigint handled internally
sumPrices(['USD 50.37', 'USD 0.000_000_000_000_213'])
// => 'USD 50.370_000_000_000_213'

// shape format shows bigint directly
asIsoPriceShape('USD 50.37')
// => { amount: 5037n, currency: 'USD' }

// cast functions accept number for convenience
asIsoPriceShape({ amount: 5037, currency: 'USD' })
// => { amount: 5037n, currency: 'USD' }

// high-precision arithmetic just works
sumPrices(['USD 50.37', 'USD 0.000_000_000_000_213'], { format: 'shape' })
// => { amount: 5_037_000_000_000_213n, currency: 'USD', exponent: 'pico.x10^-12' }
```

note: most developers should use `IsoPriceWords` (string format) and never touch bigint directly. see `define.price-bigint.md` for full rationale.

## c.13 = serialize

JSON serialization via `IsoPriceWords` (recommended for portability).

```ts
const price = { amount: 25_000_000_000_000_000n, currency: 'USD', exponent: 'nano.x10^-9' };

// serialize via words (recommended)
const words = asIsoPriceWords(price);
// => 'USD 25_000_000.000_000_000'

JSON.stringify({ total: words });
// => '{"total":"USD 25_000_000.000_000_000"}'

// round-trip restoration
asIsoPriceShape(JSON.parse(json).total);
// => { amount: 25_000_000_000_000_000n, currency: 'USD', exponent: 'nano.x10^-9' }
```

note: `IsoPriceWords` is the recommended persistence format because:
- serializes trivially (it's a string)
- avoids bigint hazards (`JSON.stringify` throws on bigint)
- portable across systems and languages
- human-readable in logs and databases

## c.14 = currency.iso4217

Standard iso 4217 currencies with automatic exponent defaults.

```ts
// words format (recommended)
asIsoPrice('$50.37')    // => 'USD 50.37' (2-decimal default)
asIsoPrice('€50.37')    // => 'EUR 50.37' (2-decimal default)
asIsoPrice('¥1000')     // => 'JPY 1000'  (0-decimal default)
asIsoPrice('₩1000')     // => 'KRW 1000'  (0-decimal default)

// shape format shows exponent defaults
asIsoPriceShape('USD 50.37')  // => { amount: 5037n, currency: 'USD' } (centi.x10^-2)
asIsoPriceShape('JPY 1000')   // => { amount: 1000n, currency: 'JPY' } (whole.x10^0)
asIsoPriceShape('BHD 1.234')  // => { amount: 1234n, currency: 'BHD' } (milli.x10^-3)
```

## c.15 = currency.custom

Custom currencies (crypto) are accepted with explicit exponent.

```ts
// words format (recommended)
'BTC 1.00000000'                    // 1 BTC (8 decimals for satoshis)
'ETH 1.000000000000000000'          // 1 ETH (18 decimals for wei)

// shape format for custom precision
asIsoPriceShape({ amount: 100_000_000, currency: 'BTC', exponent: 'nano.x10^-9' })
// => { amount: 100_000_000n, currency: 'BTC', exponent: 'nano.x10^-9' }
```

## c.16 = statistics

Statistical measures across prices.

```ts
// spread syntax (recommended)
calcPriceStdev('USD 10.00', 'USD 20.00', 'USD 30.00')
// => 'USD 8.16'

// array syntax (required when options needed)
calcPriceStdev(['USD 10.00', 'USD 20.00', 'USD 30.00'], { format: 'shape' })
// => { amount: 816n, currency: 'USD' }
```

## c.17 = currency.constraint

Constrain `IsoPriceWords` to specific currencies via generic parameter.

```ts
// default: any currency (backwards compatible)
const price: IsoPriceWords = 'USD 50.37';  // ✓
const any: IsoPriceWords = 'XYZ 50.37';    // ✓

// constrained: specific currency
const usd: IsoPriceWords<'USD'> = 'USD 50.37';  // ✓
const bad: IsoPriceWords<'USD'> = 'EUR 50.37';  // ✗ compile error

// constrained: currency union
const multi: IsoPriceWords<'USD' | 'EUR'> = 'USD 50.37';  // ✓
const nope: IsoPriceWords<'USD' | 'EUR'> = 'GBP 50.37';   // ✗ compile error

// constrained: iso 4217 only
const iso: IsoPriceWords<IsoCurrency> = 'USD 50.37';   // ✓
const crypto: IsoPriceWords<IsoCurrency> = 'BTC 1.00'; // ✗ compile error
```

arithmetic functions preserve the constraint:

```ts
// sum preserves currency constraint
sumPrices<'USD'>('USD 10.00', 'USD 20.00')
// => IsoPriceWords<'USD'>

// type alias for domain use
type UsdPrice = IsoPriceWords<'USD'>;
const total: UsdPrice = sumPrices('USD 10.00', 'USD 20.00');
```

---

# boundary cases

| case              | input                                 | output          |
| ----------------- | ------------------------------------- | --------------- |
| zero              | `'USD 0.00'`                          | valid           |
| negative          | `'USD -10.00'`                        | valid (refunds) |
| no args           | `sumPrices()`                         | compile error   |
| single item       | `sumPrices('USD 10.00')`              | `'USD 10.00'`   |
| currency mismatch | `sumPrices('USD 10.00', 'EUR 20.00')` | runtime error   |

---

# type-level enforcement

Compile-time enforcement via generics.

```ts
// currency constraint via IsoPriceWords<TCurrency>
const usd: IsoPriceWords<'USD'> = 'USD 50.37';  // ✓ compiles
const bad: IsoPriceWords<'USD'> = 'EUR 50.37';  // ✗ compile error

// spread syntax requires at least one argument
sumPrices('USD 10.00', 'USD 20.00')  // ✓ compiles
sumPrices()                           // ✗ compile error: expected at least 1 argument

// shape format with constrained currency
const shape: IsoPriceShape<'USD'> = { amount: 5037n, currency: 'USD' };  // ✓ compiles
const bad2: IsoPriceShape<'USD'> = { amount: 5037n, currency: 'EUR' };   // ✗ compile error
```
