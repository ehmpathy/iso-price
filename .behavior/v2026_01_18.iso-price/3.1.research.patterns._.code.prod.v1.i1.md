# research.patterns.code.prod = iso-price

production codepath pattern analysis for the iso-price wish.

---

# pattern.1 = domain object declaration via DomainLiteral

## citation.1

file: `src/domain.objects/Price.ts:1-38`

```ts
import { DomainLiteral } from 'domain-objects';
import Joi from 'joi';
import type { Literalize } from 'type-fns';

import { Currency } from './constants/Currency';

const schema = Joi.object().keys({
  amount: Joi.number().min(0).required(),
  currency: Joi.string()
    .valid(...Object.values(Currency))
    .required(),
});

/**
 * specifies a price
 *
 * def: price
 * > the amount of money expected, required, or given in payment for a product or service.
 *
 * note
 * - amount is specified in terms of the lowest unit in the currency
 *   - i.e., always an integer to avoid [float point sillyness](https://wiki.sei.cmu.edu/confluence/display/c/FLP02-C.+Avoid+using+float-point+numbers+when+precise+computation+is+needed)
 *   - i.e., matches the pattern set forth by Stripe
 *   - e.g., cents for USD
 * - amount can be negative -> money is moved from "seller" (a.k.a. us) to "buyer"
 *   - used to support discounts, credits, or refunds
 *   - may feel like an odd concept, but negative prices are a concept which apparently doesn't have a better name yet broadly ðŸ¤·
 *     - https://en.wikipedia.org/wiki/Negative_pricing
 */
export interface Price {
  id?: number; // included to support generate dao
  amount: number;
  currency: Literalize<Currency>;
}

export class Price extends DomainLiteral<Price> implements Price {
  public static schema = schema;
}
```

## relation to wish

the wish states:
> "we want to rename the Price dobj to IsoPrice"
> "IsoPriceWords and IsoPriceShape are distinct interfaces and IsoPrice composes both of them"

the current Price is a single shape-based domain object. the wish requires a split into IsoPriceShape (structured) and IsoPriceWords (branded string), with IsoPrice as a union type.

## verdict: [EXTEND]

- the DomainLiteral pattern will be reused for IsoPriceShape
- the shape `{ amount, currency }` will be preserved
- the Joi schema validation pattern will be extended
- the name will change from `Price` to `IsoPriceShape`
- a new IsoPriceWords branded string type will be added
- IsoPrice will become a union of both

---

# pattern.2 = currency enum with type guard

## citation.2

file: `src/domain.objects/constants/Currency.ts:1-15`

```ts
import { createIsOfEnum } from 'type-fns';

/**
 * an enum of ISO 4217 currency codes
 *
 * ref
 * - https://en.wikipedia.org/wiki/ISO_4217
 *
 * TODO: fill out
 */
export enum Currency {
  USD = 'USD',
}

export const isOfCurrency = createIsOfEnum(Currency);
```

## relation to wish

the wish states:
> "leverage IsoCurrency declaration for currency explicitly"
> "support all currencies and even crypto"

the current Currency enum only contains USD. the wish requires all ISO 4217 currencies plus crypto support.

## verdict: [REPLACE]

- the enum approach will be replaced with a string type that accepts any ISO 4217 code
- crypto currencies will be supported via open string union
- the `isOfCurrency` guard will be extended to validate against known ISO 4217 codes while it allows custom currencies

---

# pattern.3 = contract barrel export

## citation.3

file: `src/contract/index.ts:1-15`

```ts
// translation procedures

// resources
export { Currency } from '@src/domain.objects/constants/Currency';
export { Price } from '@src/domain.objects/Price';
// calculation procedures
export * from '@src/domain.operations/calc/calcPriceDivision';
export * from '@src/domain.operations/calc/calcPriceMultiplication';
export * from '@src/domain.operations/calc/calcPriceStdev';
export * from '@src/domain.operations/calc/calcPriceSubtraction';
export * from '@src/domain.operations/calc/calcPriceSummation';
// guard procedures
export { isAPrice } from '@src/domain.operations/guard/isAPrice';
export * from '@src/domain.operations/words/asPriceWord';
export * from '@src/domain.operations/words/ofPriceWord';
```

## relation to wish

the wish states:
> "asIsoPriceShape, asIsoPriceWords, isIsoPriceShape, isIsoPriceWords, asIsoPrice, isIsoPrice"

the current exports will need to be renamed and expanded to match the new convention.

## verdict: [EXTEND]

- the barrel export pattern will be preserved
- export names will change to match iso-price convention
- new exports will be added (asIsoPriceShape, asIsoPrice, isIsoPriceWords, isIsoPriceShape)

---

# pattern.4 = summation with currency validation and alias exports

## citation.4

file: `src/domain.operations/calc/calcPriceSummation.ts:1-35`

```ts
import { UnexpectedCodePathError } from 'helpful-errors';

import { Price } from '@src/domain.objects/Price';

export const calcPriceSummation = (prices: Price[]): Price => {
  // if no prices, throw error, invalid request
  const priceFirst = prices[0];
  if (!priceFirst)
    throw new UnexpectedCodePathError('no prices to sum. invalid operation', {
      prices,
    });

  // verify each price is in the same currency
  const hasDiffCurrencies = prices.some(
    (price) => price.currency !== priceFirst.currency,
  );
  if (hasDiffCurrencies)
    throw new UnexpectedCodePathError('different currencies found. cant sum', {
      prices,
    });

  // otherwise, get the total amount
  const amountTotal = prices.reduce(
    (summary, thisPrice) => summary + thisPrice.amount,
    0,
  );

  // and return the total price
  return new Price({
    amount: amountTotal,
    currency: priceFirst.currency,
  });
};

export { calcPriceSummation as sumPrices, calcPriceSummation as calcPriceSum };
```

## relation to wish

the criteria states:
> "sumPrices takes either spread args or array"
> "aliases: sumPrices, priceSum, priceSummate, priceAdd"
> "supports both IsoPriceShape and IsoPriceWords input"

the current implementation only takes array of Price shapes. the wish requires:
- support for spread args OR array
- support for IsoPriceWords input (with runtime currency validation)
- additional aliases

## verdict: [EXTEND]

- the currency validation pattern will be reused
- the reduce pattern for summation will be reused
- input signature will be extended to support spread args OR array
- input type will be extended to accept IsoPrice (shape or words)
- internal conversion from words to shape will be added
- additional aliases will be added

---

# pattern.5 = subtraction with spread args and currency validation

## citation.5

file: `src/domain.operations/calc/calcPriceSubtraction.ts:1-22`

```ts
import { UnexpectedCodePathError } from 'helpful-errors';

import { Price } from '@src/domain.objects/Price';

export const calcPriceSubtraction = (...input: [Price, Price]): Price => {
  if (input[0].currency !== input[1].currency)
    throw new UnexpectedCodePathError(
      'can not subtract prices across different currencies',
      { input },
    );

  // and return the total price
  return new Price({
    amount: input[0].amount - input[1].amount,
    currency: input[0].currency,
  });
};

export {
  calcPriceSubtraction as subPrices,
  calcPriceSubtraction as calcPriceSub,
};
```

## relation to wish

the criteria states:
> "subPrices takes either spread args or array"
> "aliases: subPrices, priceSub, priceSubtract"
> "supports both IsoPriceShape and IsoPriceWords input"

the current implementation uses spread args with exactly 2 prices. the wish requires:
- support for spread args OR array (with 2+ prices)
- support for IsoPriceWords input
- additional aliases

## verdict: [EXTEND]

- the spread args pattern will be preserved
- array input support will be added
- input type will be extended to accept IsoPrice
- additional aliases will be added

---

# pattern.6 = multiplication with named input object

## citation.6

file: `src/domain.operations/calc/calcPriceMultiplication.ts:1-13`

```ts
import { Price } from '@src/domain.objects/Price';

export const calcPriceMultiplication = (input: {
  price: Price;
  by: number;
}): Price => {
  return new Price({
    amount: input.price.amount * input.by,
    currency: input.price.currency,
  });
};

export { calcPriceMultiplication as multiplyPrice };
```

## relation to wish

the criteria states:
> "multiplyPrice({ price, by })"
> "aliases: multiplyPrice, priceMultiply"
> "supports both IsoPriceShape and IsoPriceWords input"

the current implementation matches the target signature `{ price, by }`. the wish requires:
- input type extended to accept IsoPrice (shape or words)
- additional alias

## verdict: [EXTEND]

- the named input pattern `{ price, by }` will be reused exactly
- input type will be extended to accept IsoPrice
- alias `priceMultiply` will be added

---

# pattern.7 = division with named input object

## citation.7

file: `src/domain.operations/calc/calcPriceDivision.ts:1-13`

```ts
import { Price } from '@src/domain.objects/Price';

export const calcPriceDivision = (input: {
  price: Price;
  by: number;
}): Price => {
  return new Price({
    amount: input.price.amount / input.by,
    currency: input.price.currency,
  });
};

export { calcPriceDivision as dividePrice };
```

## relation to wish

the criteria states:
> "dividePrice({ price, by })"
> "aliases: dividePrice, priceDivide"
> "supports both IsoPriceShape and IsoPriceWords input"

the current implementation matches the target signature `{ price, by }`. the wish requires:
- input type extended to accept IsoPrice
- additional alias

## verdict: [EXTEND]

- the named input pattern `{ price, by }` will be reused exactly
- input type will be extended to accept IsoPrice
- alias `priceDivide` will be added

---

# pattern.8 = standard deviation with currency validation

## citation.8

file: `src/domain.operations/calc/calcPriceStdev.ts:1-50`

```ts
import { UnexpectedCodePathError } from 'helpful-errors';

import { Price } from '@src/domain.objects/Price';

/**
 * .ref = https://stackoverflow.com/a/77664868/3068233
 */
const calcStandardDeviation = (array: number[]): number | null => {
  if (array.length < 2) return null;
  const n = array.length;
  const mean = array.reduce((a, b) => a + b) / n;
  return Math.sqrt(
    array.map((x) => (x - mean) ** 2).reduce((a, b) => a + b) / (n - 1),
  );
};

/**
 * .what = calculates the standard-deviation of the set of prices
 * .note =
 *   - this will return `null` if there are not enough prices to calculate with
 */
export const calcPriceStdev = (prices: Price[]): Price | null => {
  const priceFirst = prices[0];
  if (!priceFirst) return null;

  // verify each price is in the same currency
  const hasDiffCurrencies = prices.some(
    (price) => price.currency !== priceFirst.currency,
  );
  if (hasDiffCurrencies)
    throw new UnexpectedCodePathError(
      'different currencies found. cant calculate',
      {
        prices,
      },
    );

  // otherwise, get the total amount
  const amountStdev = calcStandardDeviation(
    prices.map((price) => price.amount),
  );

  // and return the total price
  return amountStdev === null
    ? null
    : new Price({
        amount: amountStdev,
        currency: priceFirst.currency,
      });
};
```

## relation to wish

the criteria states:
> "calcPriceStdev([...])"
> "aliases: calcPriceStdev, priceStdev"
> "supports both IsoPriceShape and IsoPriceWords input"

the current implementation takes array of Price shapes. the wish requires:
- support for IsoPriceWords input
- additional alias

## verdict: [EXTEND]

- the standard deviation calculation will be reused
- the currency validation pattern will be reused
- input type will be extended to accept IsoPrice
- alias `priceStdev` will be added

---

# pattern.9 = type guard for price shape

## citation.9

file: `src/domain.operations/guard/isAPrice.ts:1-9`

```ts
import { isOfCurrency } from '@src/domain.objects/constants/Currency';
import type { Price } from '@src/domain.objects/Price';

export const isAPrice = (val: unknown): val is Price =>
  typeof val === 'object' &&
  val !== null &&
  typeof (val as any).currency === 'string' &&
  isOfCurrency((val as any).currency) &&
  typeof (val as any).amount === 'number';
```

## relation to wish

the criteria states:
> "isIsoPrice - accepts either shape or words"
> "isIsoPriceShape - type guard for shape format specifically"
> "isIsoPriceWords - type guard for words format specifically"

the current implementation only guards for shape. the wish requires:
- separate guards for shape and words
- combined guard that accepts either

## verdict: [EXTEND]

- the shape guard pattern will be reused for isIsoPriceShape
- new isIsoPriceWords guard will be added for branded string validation
- isIsoPrice will combine both guards
- isIsoPriceWords will have `.assure()` method for convenient validation

---

# pattern.10 = cast shape to words via Intl.NumberFormat

## citation.10

file: `src/domain.operations/words/asPriceWord.ts:1-15`

```ts
import type { Price } from '@src/domain.objects/Price';

export const asPriceWord = (
  price: Price,
  options: { cents?: boolean } = { cents: true },
): string => {
  const string = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: price.currency,
  }).format(price.amount / 100);
  if (!options.cents) return string.split('.')[0]!;
  return string;
};

export { asPriceWord as castPriceToWord };
```

## relation to wish

the criteria states:
> "asIsoPriceWords({ price, with: { format, cents } })"
> "format options: prefix-symbol, prefix-code, suffix-code"
> "default format: prefix-symbol"
> "default cents: true"

the current implementation uses positional args and only supports symbol prefix format. the wish requires:
- named input `{ price, with: { format, cents } }`
- multiple format options
- passthrough for already-words input

## verdict: [REPLACE]

- the Intl.NumberFormat approach will be preserved for symbol-prefix format
- signature will change to named args with `with` options object
- multiple format options will be added
- input type will accept IsoPrice (passthrough for words)

---

# pattern.11 = cast words to shape via regex parser

## citation.11

file: `src/domain.operations/words/ofPriceWord.ts:1-25`

```ts
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';

import { Price } from '@src/domain.objects/Price';

/**
 * .what = extracts the price out of word it is defined in
 * .why =
 *   - enable convenient definitions of prices
 */
export const ofPriceWord = (word: string): Price => {
  const match = word.match(/^\$(\d+)(?:\.(\d{2}))?$/);
  if (!match)
    throw new BadRequestError('invalid price format in word', { word });
  if (!match[1])
    throw new UnexpectedCodePathError(
      'could not extract dollars from word. should not have matched',
      { word },
    );
  const dollars = parseInt(match[1], 10);
  const cents = match[2] ? parseInt(match[2], 10) : 0;
  const amount = dollars * 100 + cents;
  return new Price({ amount: amount, currency: 'USD' });
};

export { ofPriceWord as castWordToPrice };
```

## relation to wish

the criteria states:
> "isIsoPriceWords.assure('$50.37') validates and returns branded type or throws"
> "supports symbol prefix ($50.37), code prefix (USD 50.37), code suffix (50.37 USD)"
> "supports all ISO 4217 currencies"

the current implementation only supports USD symbol prefix format. the wish requires:
- support for all three format variations
- support for all ISO 4217 currencies
- integration with isIsoPriceWords.assure() pattern
- branded string return type

## verdict: [REPLACE]

- the regex parser approach will be extended to support all formats
- will be integrated into isIsoPriceWords.assure() pattern
- will support all currencies via symbol/code lookup
- will return branded IsoPriceWords type

---

# pattern.12 = package structure with domain.objects and domain.operations

## citation.12

file structure:
```
src/
  index.ts
  contract/
    index.ts
  domain.objects/
    Price.ts
    constants/
      Currency.ts
  domain.operations/
    calc/
      calcPriceSummation.ts
      calcPriceSubtraction.ts
      calcPriceMultiplication.ts
      calcPriceDivision.ts
      calcPriceStdev.ts
    guard/
      isAPrice.ts
    words/
      asPriceWord.ts
      ofPriceWord.ts
```

## relation to wish

the wish states:
> "create a comprehensive glossary of price domain objects and operations"

the current structure separates domain objects from operations. the wish requires:
- new domain objects (IsoPriceShape, IsoPriceWords)
- new operations (allocatePrice, asIsoPriceShape, asIsoPrice)
- renamed operations to match iso-price convention

## verdict: [REUSE]

- the folder structure pattern will be fully reused
- domain.objects will contain IsoPrice types
- domain.operations will contain all operations organized by category

---

# pattern.13 = helpful-errors for fail-fast validation

## citation.13

file: `src/domain.operations/calc/calcPriceSummation.ts:1-2,8-11`

```ts
import { UnexpectedCodePathError } from 'helpful-errors';
...
  if (!priceFirst)
    throw new UnexpectedCodePathError('no prices to sum. invalid operation', {
      prices,
    });
```

file: `src/domain.operations/words/ofPriceWord.ts:1,12-13`

```ts
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';
...
  if (!match)
    throw new BadRequestError('invalid price format in word', { word });
```

## relation to wish

the criteria implies fail-fast behavior:
> "an error is thrown for empty lists"
> "an error is thrown at runtime for currency mismatch with words"

the helpful-errors pattern is already in use and aligns with the wish requirements.

## verdict: [REUSE]

- UnexpectedCodePathError for internal invariant violations
- BadRequestError for invalid user input
- metadata objects for debug context

---

# pattern.14 = Joi schema validation on domain objects

## citation.14

file: `src/domain.objects/Price.ts:7-12,37`

```ts
const schema = Joi.object().keys({
  amount: Joi.number().min(0).required(),
  currency: Joi.string()
    .valid(...Object.values(Currency))
    .required(),
});
...
export class Price extends DomainLiteral<Price> implements Price {
  public static schema = schema;
}
```

## relation to wish

the criteria states:
> "amount must be integer"
> "invalid shapes are caught before runtime"

the current schema allows any number (which includes floats). the wish requires integer validation.

## verdict: [EXTEND]

- Joi schema validation pattern will be preserved
- amount validation will be updated to require integer
- currency validation will be updated to accept any ISO 4217 code or custom currency

---

# summary

| pattern | verdict | key changes |
|---------|---------|-------------|
| 1. DomainLiteral for Price | [EXTEND] | rename to IsoPriceShape, add IsoPriceWords |
| 2. Currency enum | [REPLACE] | open string type for all ISO 4217 + crypto |
| 3. contract barrel export | [EXTEND] | rename exports, add new exports |
| 4. summation with validation | [EXTEND] | spread/array support, IsoPrice input, aliases |
| 5. subtraction with spread | [EXTEND] | array support, IsoPrice input, aliases |
| 6. multiplication named input | [EXTEND] | IsoPrice input, alias |
| 7. division named input | [EXTEND] | IsoPrice input, alias |
| 8. standard deviation | [EXTEND] | IsoPrice input, alias |
| 9. type guard isAPrice | [EXTEND] | split into isIsoPriceShape, isIsoPriceWords, isIsoPrice |
| 10. asPriceWord | [REPLACE] | named args, format options, passthrough |
| 11. ofPriceWord | [REPLACE] | multi-format, all currencies, branded type |
| 12. package structure | [REUSE] | same structure, new/renamed contents |
| 13. helpful-errors | [REUSE] | same pattern |
| 14. Joi schema | [EXTEND] | integer validation, open currency |

---

# new patterns required

the patterns below are required by the criteria but do not exist in the current codebase:

## new.1 = allocatePrice operation

the criteria states:
> "allocatePrice({ price, parts, remainder })"
> "allocatePrice({ price, ratios, remainder })"

this is a new operation that splits a price into N parts with remainder distribution.

## new.2 = IsoPriceWords branded string type

the criteria states:
> "IsoPriceWords is a branded string type"
> "type safety is enforced via the brand, not template literals"

this requires a new branded string type pattern.

## new.3 = isIsoPriceWords.assure() method

the criteria states:
> "isIsoPriceWords.assure() validates and returns branded type or throws"

this requires a type guard with an `.assure()` method that throws on invalid input.

## new.4 = asIsoPriceShape cast function

the criteria states:
> "asIsoPriceShape('$50.37') => { amount: 5037, currency: 'USD' }"

this is a new cast function that converts any IsoPrice to shape.

## new.5 = asIsoPrice cast function

the criteria states:
> "asIsoPrice('$50.37') => { amount: 5037, currency: 'USD' } (returns shape by default)"

this is a new cast function that normalizes any IsoPrice to shape.

## new.6 = ISO 4217 currency metadata

to support proper minor unit treatment for all currencies, a lookup table of ISO 4217 currencies with their minor unit exponents is required.
