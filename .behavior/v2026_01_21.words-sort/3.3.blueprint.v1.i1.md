# blueprint = iso-price words comparison & sort

implementation blueprint for numeric comparison and sort utilities.

---

## context

- **wish**: `.behavior/v2026_01_21.words-sort/0.wish.md`
- **vision**: `.behavior/v2026_01_21.words-sort/1.vision.md`
- **criteria**: `.behavior/v2026_01_21.words-sort/2.criteria.blackbox.md`

---

## phase.1: comparison predicates

add comparison predicates to `isIsoPrice` namespace via separate files.

### file structure

```
src/domain.operations/guard/
├── isIsoPrice.ts                  # extend to attach .greater, .lesser, .equal
├── isIsoPrice.test.ts             # prior tests (unchanged)
├── isIsoPriceGreater.ts           # isIsoPrice.greater implementation
├── isIsoPriceGreater.test.ts      # greater predicate tests
├── isIsoPriceLesser.ts            # isIsoPrice.lesser implementation
├── isIsoPriceLesser.test.ts       # lesser predicate tests
├── isIsoPriceEqual.ts             # isIsoPrice.equal implementation
└── isIsoPriceEqual.test.ts        # equal predicate tests
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p1.1 | `isIsoPriceGreater.ts` | implement via `subPrices` — `diff.amount > 0n` |
| p1.2 | `isIsoPriceGreater.test.ts` | unit tests for greater predicate |
| p1.3 | `isIsoPriceLesser.ts` | implement via `subPrices` — `diff.amount < 0n` |
| p1.4 | `isIsoPriceLesser.test.ts` | unit tests for lesser predicate |
| p1.5 | `isIsoPriceEqual.ts` | implement via `subPrices` — `diff.amount === 0n` |
| p1.6 | `isIsoPriceEqual.test.ts` | unit tests for equal predicate |
| p1.7 | `isIsoPrice.ts` | attach `.greater`, `.lesser`, `.equal` to namespace |

### implementation notes

predicates reuse `subPrices` — it already handles normalization and currency mismatch:
- `subPrices(a, b)` → negative = lesser, positive = greater, zero = equal

```ts
// src/domain.operations/guard/isIsoPriceGreater.ts
export const isIsoPriceGreater = (a: IsoPrice, b: IsoPrice): boolean => {
  const diff = subPrices([a, b], { format: 'shape' });
  return diff.amount > 0n;
};

// src/domain.operations/guard/isIsoPriceLesser.ts
export const isIsoPriceLesser = (a: IsoPrice, b: IsoPrice): boolean => {
  const diff = subPrices([a, b], { format: 'shape' });
  return diff.amount < 0n;
};

// src/domain.operations/guard/isIsoPriceEqual.ts
export const isIsoPriceEqual = (a: IsoPrice, b: IsoPrice): boolean => {
  const diff = subPrices([a, b], { format: 'shape' });
  return diff.amount === 0n;
};

// src/domain.operations/guard/isIsoPrice.ts — attach to namespace
import { isIsoPriceGreater } from './isIsoPriceGreater';
import { isIsoPriceLesser } from './isIsoPriceLesser';
import { isIsoPriceEqual } from './isIsoPriceEqual';

isIsoPrice.greater = isIsoPriceGreater;
isIsoPrice.lesser = isIsoPriceLesser;
isIsoPrice.equal = isIsoPriceEqual;
```

### tests

unit tests (data-driven caselist):

```ts
// c.1: predicate.greater
const GREATER_CASES = [
  { description: 'greater returns true when a > b', given: { a: 'USD 100.00', b: 'USD 9.00' }, expect: { output: true } },
  { description: 'greater returns false when a == b', given: { a: 'USD 100.00', b: 'USD 100.00' }, expect: { output: false } },
  { description: 'greater returns false when a < b', given: { a: 'USD 9.00', b: 'USD 100.00' }, expect: { output: false } },
];

// c.2: predicate.lesser
const LESSER_CASES = [
  { description: 'lesser returns true when a < b', given: { a: 'USD 9.00', b: 'USD 100.00' }, expect: { output: true } },
  { description: 'lesser returns false when a == b', given: { a: 'USD 100.00', b: 'USD 100.00' }, expect: { output: false } },
  { description: 'lesser returns false when a > b', given: { a: 'USD 100.00', b: 'USD 9.00' }, expect: { output: false } },
];

// c.3: predicate.equal
const EQUAL_CASES = [
  { description: 'equal returns true for same value same format', given: { a: 'USD 100.00', b: 'USD 100.00' }, expect: { output: true } },
  { description: 'equal returns true for same value with underscores', given: { a: 'USD 1_000.00', b: 'USD 1000.00' }, expect: { output: true } },
  { description: 'equal returns true for same value different precision', given: { a: 'USD 0.25', b: 'USD 0.250_000' }, expect: { output: true } },
  { description: 'equal returns true for 0.10 vs 0.100_000', given: { a: 'USD 0.10', b: 'USD 0.100_000' }, expect: { output: true } },
  { description: 'equal returns true for 1.00 vs 1.000_000_000', given: { a: 'USD 1.00', b: 'USD 1.000_000_000' }, expect: { output: true } },
  { description: 'equal returns false for different values', given: { a: 'USD 0.25', b: 'USD 0.250_001' }, expect: { output: false } },
];

// c.4: predicate.precision-normalization
const PRECISION_NORM_CASES = [
  { description: 'greater with mixed exponents', given: { a: 'USD 0.01', b: 'USD 0.000_001' }, expect: { output: true } },
  { description: 'lesser with mixed exponents', given: { a: 'USD 0.000_001', b: 'USD 0.01' }, expect: { output: true } },
  { description: 'equal with mixed exponents false', given: { a: 'USD 0.01', b: 'USD 0.000_001' }, expect: { equalOutput: false } },
];

// c.5: predicate.currency-mismatch
const CURRENCY_MISMATCH_CASES = [
  { description: 'greater failsfast on currency mismatch', given: { a: 'USD 100.00', b: 'EUR 50.00' }, expect: { throws: 'cannot compare prices with different currencies' } },
  { description: 'lesser failsfast on currency mismatch', given: { a: 'USD 100.00', b: 'EUR 50.00' }, expect: { throws: 'cannot compare prices with different currencies' } },
  { description: 'equal failsfast on currency mismatch', given: { a: 'USD 100.00', b: 'EUR 50.00' }, expect: { throws: 'cannot compare prices with different currencies' } },
];

// boundary cases
const BOUNDARY_CASES = [
  { description: 'zero values equal', given: { a: 'USD 0.00', b: 'USD 0' }, expect: { equalOutput: true } },
  { description: 'negative comparison', given: { a: 'USD -5.00', b: 'USD -10.00' }, expect: { greaterOutput: true } },
  { description: 'large values', given: { a: 'USD 999_999_999.99', b: 'USD 1.00' }, expect: { greaterOutput: true } },
  { description: 'small values', given: { a: 'USD 0.000_000_001', b: 'USD 0.000_000_002' }, expect: { lesserOutput: true } },
  { description: 'mixed sign', given: { a: 'USD 1.00', b: 'USD -1.00' }, expect: { greaterOutput: true } },
];

// c.16: input.mixed-formats
const MIXED_FORMAT_CASES = [
  { description: 'greater accepts shape input', given: { a: 'USD 100.00', b: { amount: 900n, currency: 'USD' } }, expect: { output: true } },
  { description: 'equal accepts human input', given: { a: '$50.00', b: 'USD 50.00' }, expect: { output: true } },
];
```

| test file | covers |
| --------- | ------ |
| `isIsoPriceGreater.test.ts` | c.1, c.4-c.5, c.16, boundary cases for greater |
| `isIsoPriceLesser.test.ts` | c.2, c.4-c.5, c.16, boundary cases for lesser |
| `isIsoPriceEqual.test.ts` | c.3, c.4-c.5, c.16, boundary cases for equal |

---

## phase.2: sort operations

add sort operations to `asIsoPrice` namespace via separate files.

### file structure

```
src/domain.operations/cast/
├── asIsoPrice.ts              # extend to attach .sorted
├── asIsoPrice.test.ts         # prior tests (unchanged)
├── asIsoPriceSorted.ts        # asIsoPrice.sorted implementation
└── asIsoPriceSorted.test.ts   # sort unit tests
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p2.1 | `asIsoPriceSorted.ts` | implement `asIsoPriceSorted(prices, options?)` with asc/desc |
| p2.2 | `asIsoPriceSorted.ts` | attach `.asc` and `.desc` methods to the function |
| p2.3 | `asIsoPriceSorted.test.ts` | unit tests for all sort behaviors |
| p2.4 | `asIsoPrice.ts` | attach `.sorted` to namespace |

### implementation notes

sort must:
- return new array (immutable)
- preserve relative order of equal elements (stable sort)
- normalize to most granular precision for comparison
- throw on currency mismatch
- accept any `IsoPrice` input, return `IsoPriceWords[]`

```ts
// src/domain.operations/cast/asIsoPriceSorted.ts
const _asIsoPriceSorted = (
  prices: IsoPrice[],
  options?: { order?: 'asc' | 'desc' },
): IsoPriceWords[] => {
  // handle empty and single element
  if (prices.length === 0) return [];
  if (prices.length === 1) return [asIsoPriceWords(prices[0])];

  // convert to words with original index for stable sort
  const wordsWithIndex = prices.map((p, i) => ({
    words: asIsoPriceWords(p),
    originalIndex: i,
  }));

  // validate all same currency upfront for clear error message
  const currencies = new Set(wordsWithIndex.map(w => w.words.split(' ')[0]));
  if (currencies.size > 1)
    throw new BadRequestError('cannot sort prices with different currencies', {
      currencies: Array.from(currencies),
    });

  // stable sort via subPrices comparison + originalIndex tiebreaker
  const order = options?.order ?? 'asc';
  wordsWithIndex.sort((a, b) => {
    const diff = subPrices([a.words, b.words], { format: 'shape' });
    if (diff.amount === 0n) return a.originalIndex - b.originalIndex;
    const isNegative = diff.amount < 0n;
    return order === 'asc'
      ? (isNegative ? -1 : 1)
      : (isNegative ? 1 : -1);
  });

  return wordsWithIndex.map(w => w.words);
};

// attach .asc and .desc methods
export const asIsoPriceSorted = Object.assign(_asIsoPriceSorted, {
  asc: (prices: IsoPrice[]): IsoPriceWords[] =>
    _asIsoPriceSorted(prices, { order: 'asc' }),
  desc: (prices: IsoPrice[]): IsoPriceWords[] =>
    _asIsoPriceSorted(prices, { order: 'desc' }),
});

// src/domain.operations/cast/asIsoPrice.ts — attach to namespace
import { asIsoPriceSorted } from './asIsoPriceSorted';

asIsoPrice.sorted = asIsoPriceSorted;
```

### tests

unit tests (data-driven caselist):

```ts
// c.6: sort.default
const SORT_DEFAULT_CASES = [
  {
    description: 'default sorts asc',
    given: { prices: ['USD 100.00', 'USD 9.00', 'USD 50.00'] },
    expect: { output: ['USD 9.00', 'USD 50.00', 'USD 100.00'] },
  },
];

// c.7: sort.options
const SORT_OPTIONS_CASES = [
  {
    description: 'options asc orders low to high',
    given: { prices: ['USD 100.00', 'USD 9.00', 'USD 50.00'], options: { order: 'asc' } },
    expect: { output: ['USD 9.00', 'USD 50.00', 'USD 100.00'] },
  },
  {
    description: 'options desc orders high to low',
    given: { prices: ['USD 100.00', 'USD 9.00', 'USD 50.00'], options: { order: 'desc' } },
    expect: { output: ['USD 100.00', 'USD 50.00', 'USD 9.00'] },
  },
];

// c.8: sort.methods
const SORT_METHOD_CASES = [
  {
    description: 'sorted.asc orders low to high',
    given: { prices: ['USD 100.00', 'USD 9.00', 'USD 50.00'], method: 'asc' },
    expect: { output: ['USD 9.00', 'USD 50.00', 'USD 100.00'] },
  },
  {
    description: 'sorted.desc orders high to low',
    given: { prices: ['USD 100.00', 'USD 9.00', 'USD 50.00'], method: 'desc' },
    expect: { output: ['USD 100.00', 'USD 50.00', 'USD 9.00'] },
  },
];

// c.9: sort.immutable
const SORT_IMMUTABLE_CASES = [
  {
    description: 'original array unchanged',
    given: { prices: ['USD 100.00', 'USD 9.00'] },
    expect: { originalUnchanged: true, newReference: true },
  },
];

// c.10: sort.precision-normalization
const SORT_PRECISION_CASES = [
  {
    description: 'mixed exponents sort by numeric value',
    given: { prices: ['USD 1.00', 'USD 0.000_001', 'USD 0.50'] },
    expect: { output: ['USD 0.000_001', 'USD 0.50', 'USD 1.00'] },
  },
  {
    description: 'mixed exponents desc',
    given: { prices: ['USD 1.00', 'USD 0.000_001', 'USD 0.50'], method: 'desc' },
    expect: { output: ['USD 1.00', 'USD 0.50', 'USD 0.000_001'] },
  },
];

// c.11: sort.currency-mismatch
const SORT_CURRENCY_MISMATCH_CASES = [
  {
    description: 'failsfast on mixed currencies',
    given: { prices: ['USD 100.00', 'EUR 50.00'] },
    expect: { throws: 'cannot sort prices with different currencies' },
  },
];

// c.12: sort.empty
const SORT_EMPTY_CASES = [
  { description: 'empty array returns empty', given: { prices: [] }, expect: { output: [] } },
];

// c.13: sort.single
const SORT_SINGLE_CASES = [
  {
    description: 'single element returns array with same element',
    given: { prices: ['USD 100.00'] },
    expect: { output: ['USD 100.00'], newReference: true },
  },
];

// c.14: sort.duplicates
const SORT_DUPLICATE_CASES = [
  {
    description: 'duplicates preserved',
    given: { prices: ['USD 50.00', 'USD 100.00', 'USD 50.00'] },
    expect: { output: ['USD 50.00', 'USD 50.00', 'USD 100.00'] },
  },
];

// c.15: sort.stable
const SORT_STABLE_CASES = [
  {
    description: 'equal values preserve relative order',
    given: { prices: ['USD 50.00', 'USD 50.000_000', 'USD 50'] },
    expect: { output: ['USD 50.00', 'USD 50.000_000', 'USD 50'] },
  },
];

// c.16: input.mixed-formats
const SORT_MIXED_FORMAT_CASES = [
  {
    description: 'accepts mixed formats returns words',
    given: { prices: ['USD 100.00', { amount: 900n, currency: 'USD' }, '$50.00'] },
    expect: { output: ['USD 9.00', 'USD 50.00', 'USD 100.00'] },
  },
];
```

| test file | covers |
| --------- | ------ |
| `asIsoPriceSorted.test.ts` | c.6-c.16, all sort criteria |
| `asIsoPrice.test.ts` | integration tests for .sorted namespace |

---

## phase.3: exports and contract

update public api.

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p3.1 | `contract/index.ts` | ensure `isIsoPrice` exports include predicates |
| p3.2 | `contract/index.ts` | ensure `asIsoPrice` exports include `.sorted` |

### exports

the prior exports should automatically expose the new methods since they are added to the `isIsoPrice` and `asIsoPrice` objects:

```ts
// prior exports already expose extended namespaces
export { isIsoPrice };   // now includes .greater, .lesser, .equal
export { asIsoPrice };   // now includes .sorted, .sorted.asc, .sorted.desc
```

---

## phase.4: acceptance tests

blackbox acceptance tests for vision experiences.

### file structure

```
src/contract/
└── index.acceptance.test.ts   # extend with sort/comparison tests
```

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p4.1 | `index.acceptance.test.ts` | add experience.1: sort invoice line items |
| p4.2 | `index.acceptance.test.ts` | add experience.2: check if total exceeds budget limit |
| p4.3 | `index.acceptance.test.ts` | add experience.3: find the bid that is best in an auction |

### tests

acceptance tests that cover vision experiences:

```ts
given('[case.sort.1] sort invoice line items by amount', () => {
  const lineItems: IsoPriceWords[] = [
    'USD 9.99',
    'USD 100.00',
    'USD 25.50',
    'USD 1_000.00',
  ];

  when('[t0] before any changes', () => {
    then('native sort produces wrong order', () => {
      const nativeSorted = [...lineItems].sort();
      // lexicographic: '1' < '2' < '9'
      expect(nativeSorted).toEqual([
        'USD 1_000.00',
        'USD 100.00',
        'USD 25.50',
        'USD 9.99',
      ]);
    });
  });

  when('[t1] sorted desc for display', () => {
    then('asIsoPrice.sorted.desc returns correct numeric order', () => {
      const sorted = asIsoPrice.sorted.desc(lineItems);
      expect(sorted).toEqual([
        'USD 1_000.00',
        'USD 100.00',
        'USD 25.50',
        'USD 9.99',
      ]);
    });
  });

  when('[t2] sorted asc for later steps', () => {
    then('asIsoPrice.sorted returns correct numeric order', () => {
      const sorted = asIsoPrice.sorted(lineItems);
      expect(sorted).toEqual([
        'USD 9.99',
        'USD 25.50',
        'USD 100.00',
        'USD 1_000.00',
      ]);
    });
  });
});

given('[case.sort.2] check if total exceeds budget limit', () => {
  const total: IsoPriceWords = 'USD 100.00';
  const limit: IsoPriceWords = 'USD 50.00';

  when('[t0] before any changes', () => {
    then('native comparison produces wrong result', () => {
      // '1' < '5' in ascii
      expect(total > limit).toEqual(false);
    });
  });

  when('[t1] check with isIsoPrice.greater', () => {
    then('returns true for total > limit', () => {
      expect(isIsoPrice.greater(total, limit)).toEqual(true);
    });
  });

  when('[t2] comparison with different precision', () => {
    const micro = 'USD 0.000_001';
    const cents = 'USD 0.01';

    then('greater works with mixed exponents', () => {
      expect(isIsoPrice.greater(cents, micro)).toEqual(true);
    });

    then('lesser works with mixed exponents', () => {
      expect(isIsoPrice.lesser(micro, cents)).toEqual(true);
    });
  });
});

given('[case.sort.3] find the bid that is best in an auction', () => {
  const bids: IsoPriceWords[] = [
    'USD 250.00',
    'USD 1_500.00',
    'USD 99.99',
    'USD 750.00',
  ];

  when('[t0] get best bid', () => {
    then('sorted.desc[0] returns the one that is best', () => {
      const [bidBest] = asIsoPrice.sorted.desc(bids);
      expect(bidBest).toEqual('USD 1_500.00');
    });
  });

  when('[t1] check if new bid beats current best', () => {
    const bidCurrent = 'USD 1_500.00';
    const bidNew = 'USD 2_000.00';

    then('isIsoPrice.greater identifies new leader', () => {
      expect(isIsoPrice.greater(bidNew, bidCurrent)).toEqual(true);
    });
  });
});

given('[case.sort.4] equality with different precision', () => {
  when('[t0] compare same value different format', () => {
    then('equal returns true for 0.25 vs 0.250_000', () => {
      expect(isIsoPrice.equal('USD 0.25', 'USD 0.250_000')).toEqual(true);
    });

    then('equal returns true for 1_000.00 vs 1000.00', () => {
      expect(isIsoPrice.equal('USD 1_000.00', 'USD 1000.00')).toEqual(true);
    });
  });

  when('[t1] compare different values', () => {
    then('equal returns false for 0.25 vs 0.250_001', () => {
      expect(isIsoPrice.equal('USD 0.25', 'USD 0.250_001')).toEqual(false);
    });
  });
});

given('[case.sort.5] currency mismatch fail fast', () => {
  when('[t0] compare different currencies', () => {
    then('greater failsfast with descriptive error', async () => {
      const error = await getError(() =>
        isIsoPrice.greater('USD 100.00', 'EUR 50.00'),
      );
      expect(error).toBeInstanceOf(BadRequestError);
      expect(error.message).toContain('cannot compare prices with different currencies');
    });
  });

  when('[t1] sort different currencies', () => {
    then('sorted failsfast with descriptive error', async () => {
      const error = await getError(() =>
        asIsoPrice.sorted(['USD 100.00', 'EUR 50.00']),
      );
      expect(error).toBeInstanceOf(BadRequestError);
      expect(error.message).toContain('cannot sort prices with different currencies');
    });
  });
});
```

---

## test coverage matrix

| phase | scope | type | coverage |
| ----- | ----- | ---- | -------- |
| p1.1-p1.2 | isIsoPriceGreater | unit | c.1, boundary cases |
| p1.3-p1.4 | isIsoPriceLesser | unit | c.2, boundary cases |
| p1.5-p1.6 | isIsoPriceEqual | unit | c.3, precision normalization |
| p2.1-p2.3 | asIsoPriceSorted | unit | c.6-c.16, all sort criteria |
| p3 | exports | build | `npm run build`, namespace verification |
| p4 | acceptance | acceptance | vision.experience.1-3 end-to-end |
| p5 | documentation | manual | readme examples accurate and complete |

---

## dependencies

no new dependencies required. uses:

| package | purpose |
| ------- | ------- |
| `helpful-errors` | BadRequestError for currency mismatch |
| `test-fns` | given/when/then test structure |

---

## implementation order

1. **p1.1-p1.2**: implement `isIsoPriceGreater.ts` + tests
2. **p1.3-p1.4**: implement `isIsoPriceLesser.ts` + tests
3. **p1.5-p1.6**: implement `isIsoPriceEqual.ts` + tests
4. **p1.7**: attach predicates to `isIsoPrice` namespace
5. **p2.1-p2.3**: implement `asIsoPriceSorted.ts` with `.asc`/`.desc` + tests
6. **p2.4**: attach `.sorted` to `asIsoPrice` namespace
7. **p3.1-p3.2**: verify exports (likely no changes needed)
8. **p4.1-p4.3**: add acceptance tests
9. **p5.1**: update readme with comparison and sort documentation
10. **verify**: `npm run test` all pass

---

## phase.5: documentation

update readme with new api surface.

### tasks

| task | file | description |
| ---- | ---- | ----------- |
| p5.1 | `readme.md` | add comparison and sort examples |

### content to add

```md
## comparison

compare prices numerically — avoids the string comparison footgun:

\`\`\`ts
// string comparison is wrong
'USD 100.00' > 'USD 9.00'   // false — '1' < '9' in ascii

// numeric comparison is correct
isIsoPrice.greater('USD 100.00', 'USD 9.00')  // true
isIsoPrice.lesser('USD 9.00', 'USD 100.00')   // true
isIsoPrice.equal('USD 100.00', 'USD 100.00')  // true

// works with different precision
isIsoPrice.equal('USD 0.25', 'USD 0.250_000') // true

// failsfast on currency mismatch
isIsoPrice.greater('USD 100.00', 'EUR 50.00') // failsfast
\`\`\`

## sort

sort prices numerically:

\`\`\`ts
const prices = ['USD 100.00', 'USD 9.00', 'USD 50.00'];

// default: asc (low to high)
asIsoPrice.sorted(prices)
// => ['USD 9.00', 'USD 50.00', 'USD 100.00']

// options style
asIsoPrice.sorted(prices, { order: 'desc' })
// => ['USD 100.00', 'USD 50.00', 'USD 9.00']

// method style
asIsoPrice.sorted.asc(prices)
asIsoPrice.sorted.desc(prices)

// immutable — original array unchanged
// stable — equal values preserve order
// failsfast on currency mismatch
\`\`\`
```

---

## notes

### api design decisions

1. **`lesser` not `less`** — pairs symmetrically with `greater`
2. **namespace extension** — `isIsoPrice.*` for predicates, `asIsoPrice.*` for transformations
3. **both styles supported** — `sorted(arr, { order: 'desc' })` AND `sorted.desc(arr)`
4. **immutable** — sort always returns new array
5. **stable** — equal elements preserve original order

### reuse note

predicates and sort both leverage `subPrices` for comparison — no new helper needed. `subPrices` already:
- normalizes to most granular precision
- failsfast on currency mismatch
- accepts any `IsoPrice` input

### typescript types

the extended namespaces require careful type declarations:

```ts
// isIsoPrice becomes a callable with additional properties
interface IsIsoPrice {
  (value: unknown): value is IsoPrice;
  assure: (value: unknown) => asserts value is IsoPrice;
  greater: (a: IsoPrice, b: IsoPrice) => boolean;
  lesser: (a: IsoPrice, b: IsoPrice) => boolean;
  equal: (a: IsoPrice, b: IsoPrice) => boolean;
}

// asIsoPrice becomes a callable with additional properties
interface AsIsoPrice {
  <TCurrency extends string>(input: IsoPrice<TCurrency>, options?: { currency?: TCurrency }): IsoPriceWords<TCurrency>;
  sorted: AsIsoPriceSorted;
}

interface AsIsoPriceSorted {
  (prices: IsoPrice[], options?: { order?: 'asc' | 'desc' }): IsoPriceWords[];
  asc: (prices: IsoPrice[]) => IsoPriceWords[];
  desc: (prices: IsoPrice[]) => IsoPriceWords[];
}
```
