# vision = iso-price words comparison & sort

## .what

iso-price provides intuitive comparison and sort utilities for `IsoPriceWords` â€” so developers can compare and sort prices without the javascript string comparison footgun.

## .why

javascript string comparison is lexicographic, not numeric:

```ts
'USD 100.00' > 'USD 9.00'   // false ðŸ˜¬ ('1' < '9' in ascii)
'USD 9.00' > 'USD 10.00'    // true ðŸ˜¬
```

this is a silent footgun â€” no error, just wrong results. iso-price eliminates this hazard with a pit-of-success api.

## .who

any developer who:
- sorts price arrays for display (invoices, line items, leaderboards)
- compares prices in conditionals (limit checks, threshold alerts)
- wants numeric correctness without manual parse

## .experience.1: sort invoice line items by amount

a developer builds an invoice ui. they need to display line items sorted by amount, highest first.

### the footgun (without iso-price)

```ts
const lineItems: IsoPriceWords[] = [
  'USD 9.99',
  'USD 100.00',
  'USD 25.50',
  'USD 1_000.00',
];

// ðŸ‘Ž wrong â€” lexicographic sort
lineItems.sort();
// => ['USD 1_000.00', 'USD 100.00', 'USD 25.50', 'USD 9.99']
// (sorted by ascii: '1' < '2' < '9')
```

### the pit of success (with iso-price)

```ts
import { asIsoPrice } from 'iso-price';

const sorted = asIsoPrice.sorted.desc(lineItems);
// => ['USD 1_000.00', 'USD 100.00', 'USD 25.50', 'USD 9.99'] âœ“

// or via options
const sortedViaOptions = asIsoPrice.sorted(lineItems, { order: 'desc' });
// => ['USD 1_000.00', 'USD 100.00', 'USD 25.50', 'USD 9.99'] âœ“

// asc order (default)
const sortedAsc = asIsoPrice.sorted(lineItems);
// => ['USD 9.99', 'USD 25.50', 'USD 100.00', 'USD 1_000.00'] âœ“

// explicit asc â€” method style
const explicitAsc = asIsoPrice.sorted.asc(lineItems);
// => ['USD 9.99', 'USD 25.50', 'USD 100.00', 'USD 1_000.00'] âœ“

// explicit asc â€” options style
const explicitAscOptions = asIsoPrice.sorted(lineItems, { order: 'asc' });
// => ['USD 9.99', 'USD 25.50', 'USD 100.00', 'USD 1_000.00'] âœ“
```

## .experience.2: check if total exceeds budget limit

a developer enforces spend limits. they need to compare a total against a threshold.

### the footgun (without iso-price)

```ts
const total: IsoPriceWords = 'USD 100.00';
const limit: IsoPriceWords = 'USD 50.00';

// ðŸ‘Ž wrong â€” string comparison
if (total > limit) {
  // never executes! '1' < '5' in ascii
  throw new Error('budget exceeded');
}
```

### the pit of success (with iso-price)

```ts
import { isIsoPrice } from 'iso-price';

if (isIsoPrice.greater(total, limit)) {
  // executes correctly âœ“
  throw new Error('budget exceeded');
}

// other predicates
isIsoPrice.lesser(a, b)     // a < b
isIsoPrice.equal(a, b)      // a === b (numerically)
```

## .experience.3: find the highest bid in an auction

a developer builds an auction system. they need to find the winner (highest) bid.

```ts
import { asIsoPrice, isIsoPrice } from 'iso-price';

const bids: IsoPriceWords[] = [
  'USD 250.00',
  'USD 1_500.00',
  'USD 99.99',
  'USD 750.00',
];

// get highest bid
const [bidHighest] = asIsoPrice.sorted.desc(bids);
// => 'USD 1_500.00' âœ“

// or check if new bid beats current highest
const bidNew = 'USD 2_000.00';
if (isIsoPrice.greater(bidNew, bidHighest)) {
  // new high bid! âœ“
}
```

## .edge cases & pit of success

### different currencies â†’ fail fast

prices with different currencies cannot be compared â€” that's a domain error, not a numeric operation.

```ts
isIsoPrice.greater('USD 100.00', 'EUR 50.00')
// => throws: cannot compare prices with different currencies

asIsoPrice.sorted(['USD 100.00', 'EUR 50.00'])
// => throws: cannot sort prices with different currencies
```

the library fails fast rather than produce meaningless results.

### different exponents â†’ normalized automatically

prices with different precision levels are normalized before comparison.

```ts
const micro = 'USD 0.000_001';    // micro-dollar
const cents = 'USD 0.01';          // cent

isIsoPrice.greater(cents, micro)   // true âœ“ (0.01 > 0.000001)
isIsoPrice.lesser(micro, cents)    // true âœ“

// sort mixed exponents works correctly
asIsoPrice.sorted(['USD 1.00', 'USD 0.000_001', 'USD 0.50'])
// => ['USD 0.000_001', 'USD 0.50', 'USD 1.00'] âœ“
```

### numeric equality via bigint at most granular precision

two prices that represent the same value are equal, regardless of format or precision. internally, both values are normalized to bigint at the most granular precision, then compared.

```ts
// different format, same value
isIsoPrice.equal('USD 100.00', 'USD 100')        // true âœ“
isIsoPrice.equal('USD 1_000.00', 'USD 1000.00')  // true âœ“

// different precision, same value
isIsoPrice.equal('USD 0.25', 'USD 0.250_000')    // true âœ“
// internally: 250_000n === 250_000n (both normalized to micro-dollars)

isIsoPrice.equal('USD 0.10', 'USD 0.100_000')    // true âœ“
// internally: 100_000n === 100_000n

// different precision, different value
isIsoPrice.equal('USD 0.25', 'USD 0.250_001')    // false âœ“
// internally: 250_000n !== 250_001n
```

this ensures precision differences never cause false negatives â€” `$0.25` and `$0.250_000` are the same amount of money.

### empty array â†’ returns empty

```ts
asIsoPrice.sorted([])  // => [] (no error, just empty)
```

### single element â†’ returns copy

```ts
asIsoPrice.sorted(['USD 100.00'])  // => ['USD 100.00']
```

### immutable â€” returns new array

the original array is never mutated.

```ts
const original = ['USD 100.00', 'USD 9.00'];
const sorted = asIsoPrice.sorted(original);

original  // => ['USD 100.00', 'USD 9.00'] (unchanged)
sorted    // => ['USD 9.00', 'USD 100.00'] (new array)
```

## .api summary

```ts
// predicates (is* = boolean)
isIsoPrice(value)              // type guard (prior)
isIsoPrice.greater(a, b)       // a > b numerically
isIsoPrice.lesser(a, b)        // a < b numerically
isIsoPrice.equal(a, b)         // a === b numerically

// transformations (as* = new value)
asIsoPrice(input)                            // cast to IsoPriceWords (prior)
asIsoPrice.sorted(prices)                    // sort asc (default)
asIsoPrice.sorted(prices, { order: 'asc' })  // sort asc (options)
asIsoPrice.sorted(prices, { order: 'desc' }) // sort desc (options)
asIsoPrice.sorted.asc(prices)                // sort asc (method)
asIsoPrice.sorted.desc(prices)               // sort desc (method)
```

## .principles

1. **fail fast on currency mismatch** â€” compare usd to eur is a domain error, not a numeric operation
2. **normalize precision automatically** â€” mixed exponents just work
3. **numeric equality** â€” format differences don't affect comparison
4. **immutable** â€” sort returns a new array, never mutates
5. **intuitive namespaces** â€” `isIsoPrice.*` for predicates, `asIsoPrice.*` for transformations
