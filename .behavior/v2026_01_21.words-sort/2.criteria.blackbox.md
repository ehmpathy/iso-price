# blackbox criteria = iso-price words comparison & sort

experience bounds for numeric comparison and sort of `IsoPriceWords`.

---

# api surface

```ts
// predicates — extend isIsoPrice namespace
isIsoPrice.greater(a: IsoPrice, b: IsoPrice): boolean
isIsoPrice.lesser(a: IsoPrice, b: IsoPrice): boolean
isIsoPrice.equal(a: IsoPrice, b: IsoPrice): boolean

// sort — extend asIsoPrice namespace
asIsoPrice.sorted(prices: IsoPrice[]): IsoPriceWords[]
asIsoPrice.sorted(prices: IsoPrice[], options: { order: 'asc' | 'desc' }): IsoPriceWords[]
asIsoPrice.sorted.asc(prices: IsoPrice[]): IsoPriceWords[]
asIsoPrice.sorted.desc(prices: IsoPrice[]): IsoPriceWords[]
```

---

# criteria

## c.1 = predicate.greater

given('two prices of the same currency')
  when('first price is numerically greater than second')
    then('isIsoPrice.greater returns true')
      sothat('developers can compare prices without string comparison footgun')
  when('first price is numerically equal to second')
    then('isIsoPrice.greater returns false')
  when('first price is numerically lesser than second')
    then('isIsoPrice.greater returns false')

```ts
isIsoPrice.greater('USD 100.00', 'USD 9.00')   // => true (100 > 9)
isIsoPrice.greater('USD 9.00', 'USD 100.00')   // => false
isIsoPrice.greater('USD 100.00', 'USD 100.00') // => false
```

## c.2 = predicate.lesser

given('two prices of the same currency')
  when('first price is numerically lesser than second')
    then('isIsoPrice.lesser returns true')
  when('first price is numerically equal to second')
    then('isIsoPrice.lesser returns false')
  when('first price is numerically greater than second')
    then('isIsoPrice.lesser returns false')

```ts
isIsoPrice.lesser('USD 9.00', 'USD 100.00')   // => true (9 < 100)
isIsoPrice.lesser('USD 100.00', 'USD 9.00')   // => false
isIsoPrice.lesser('USD 100.00', 'USD 100.00') // => false
```

## c.3 = predicate.equal

given('two prices of the same currency')
  when('prices represent the same numeric value')
    then('isIsoPrice.equal returns true')
      sothat('format and precision differences do not affect equality')
  when('prices represent different numeric values')
    then('isIsoPrice.equal returns false')

```ts
// same value, same format
isIsoPrice.equal('USD 100.00', 'USD 100.00')      // => true

// same value, different format (underscores)
isIsoPrice.equal('USD 1_000.00', 'USD 1000.00')   // => true

// same value, different precision
isIsoPrice.equal('USD 0.25', 'USD 0.250_000')     // => true
// internally: 250_000n === 250_000n (normalized to most granular)

isIsoPrice.equal('USD 0.10', 'USD 0.100_000')     // => true
isIsoPrice.equal('USD 1.00', 'USD 1.000_000_000') // => true

// different value, different precision
isIsoPrice.equal('USD 0.25', 'USD 0.250_001')     // => false
// internally: 250_000n !== 250_001n
```

## c.4 = predicate.precision-normalization

given('two prices with different exponents')
  when('compared via any predicate')
    then('both are normalized to most granular precision before comparison')
      sothat('mixed-precision comparisons produce correct results')

```ts
const micro = 'USD 0.000_001';   // micro-dollar precision
const cents = 'USD 0.01';         // cent precision

isIsoPrice.greater(cents, micro)  // => true (0.01 > 0.000001)
isIsoPrice.lesser(micro, cents)   // => true
isIsoPrice.equal(cents, micro)    // => false
```

## c.5 = predicate.currency-mismatch

given('two prices with different currencies')
  when('compared via any predicate')
    then('throws error')
      sothat('meaningless cross-currency comparisons are prevented')

```ts
isIsoPrice.greater('USD 100.00', 'EUR 50.00')
// => throws: cannot compare prices with different currencies

isIsoPrice.lesser('USD 100.00', 'EUR 50.00')
// => throws: cannot compare prices with different currencies

isIsoPrice.equal('USD 100.00', 'EUR 50.00')
// => throws: cannot compare prices with different currencies
```

## c.6 = sort.default

given('an array of prices')
  when('asIsoPrice.sorted is called without options')
    then('returns new array sorted in asc order')
      sothat('default behavior is intuitive (lowest first)')

```ts
const prices = ['USD 100.00', 'USD 9.00', 'USD 50.00'];

asIsoPrice.sorted(prices)
// => ['USD 9.00', 'USD 50.00', 'USD 100.00']
```

## c.7 = sort.options

given('an array of prices')
  when('asIsoPrice.sorted is called with { order: "asc" }')
    then('returns new array sorted in asc order')
  when('asIsoPrice.sorted is called with { order: "desc" }')
    then('returns new array sorted in desc order')

```ts
const prices = ['USD 100.00', 'USD 9.00', 'USD 50.00'];

asIsoPrice.sorted(prices, { order: 'asc' })
// => ['USD 9.00', 'USD 50.00', 'USD 100.00']

asIsoPrice.sorted(prices, { order: 'desc' })
// => ['USD 100.00', 'USD 50.00', 'USD 9.00']
```

## c.8 = sort.methods

given('an array of prices')
  when('asIsoPrice.sorted.asc is called')
    then('returns new array sorted in asc order')
  when('asIsoPrice.sorted.desc is called')
    then('returns new array sorted in desc order')

```ts
const prices = ['USD 100.00', 'USD 9.00', 'USD 50.00'];

asIsoPrice.sorted.asc(prices)
// => ['USD 9.00', 'USD 50.00', 'USD 100.00']

asIsoPrice.sorted.desc(prices)
// => ['USD 100.00', 'USD 50.00', 'USD 9.00']
```

## c.9 = sort.immutable

given('an array of prices')
  when('sorted via any method')
    then('original array is not mutated')
    then('new array is returned')
      sothat('immutability is preserved')

```ts
const original = ['USD 100.00', 'USD 9.00'];
const sorted = asIsoPrice.sorted(original);

original  // => ['USD 100.00', 'USD 9.00'] (unchanged)
sorted    // => ['USD 9.00', 'USD 100.00'] (new array)

original === sorted  // => false (different reference)
```

## c.10 = sort.precision-normalization

given('an array of prices with mixed exponents')
  when('sorted')
    then('prices are compared by numeric value regardless of precision')
      sothat('mixed-precision arrays sort correctly')

```ts
const prices = ['USD 1.00', 'USD 0.000_001', 'USD 0.50'];

asIsoPrice.sorted(prices)
// => ['USD 0.000_001', 'USD 0.50', 'USD 1.00']

asIsoPrice.sorted.desc(prices)
// => ['USD 1.00', 'USD 0.50', 'USD 0.000_001']
```

## c.11 = sort.currency-mismatch

given('an array with prices of different currencies')
  when('sorted')
    then('throws error')
      sothat('meaningless cross-currency sorts are prevented')

```ts
asIsoPrice.sorted(['USD 100.00', 'EUR 50.00'])
// => throws: cannot sort prices with different currencies
```

## c.12 = sort.empty

given('an empty array')
  when('sorted')
    then('returns empty array')
    then('does not throw')

```ts
asIsoPrice.sorted([])  // => []
```

## c.13 = sort.single

given('an array with one element')
  when('sorted')
    then('returns array with same element')
    then('returned array is a new reference')

```ts
const single = ['USD 100.00'];
const sorted = asIsoPrice.sorted(single);

sorted         // => ['USD 100.00']
single === sorted  // => false (new array)
```

## c.14 = sort.duplicates

given('an array with duplicate values')
  when('sorted')
    then('all duplicates are preserved in output')

```ts
const prices = ['USD 50.00', 'USD 100.00', 'USD 50.00'];

asIsoPrice.sorted(prices)
// => ['USD 50.00', 'USD 50.00', 'USD 100.00']
```

## c.15 = sort.stable

given('an array with equal values')
  when('sorted')
    then('relative order of equal elements is preserved')
      sothat('sort is stable')

```ts
const prices = ['USD 50.00', 'USD 50.000_000', 'USD 50'];
// all three represent the same numeric value

asIsoPrice.sorted(prices)
// => ['USD 50.00', 'USD 50.000_000', 'USD 50'] (order preserved)
```

## c.16 = input.mixed-formats

given('prices in mixed formats (words, shape, human)')
  when('compared or sorted')
    then('all formats are accepted')
    then('output is IsoPriceWords')

```ts
// predicates accept mixed input
isIsoPrice.greater('USD 100.00', { amount: 900n, currency: 'USD' })  // => true
isIsoPrice.equal('$50.00', 'USD 50.00')  // => true

// sort accepts mixed input, returns words
asIsoPrice.sorted([
  'USD 100.00',
  { amount: 900n, currency: 'USD' },
  '$50.00',
])
// => ['$50.00', { amount: 900n, currency: 'USD' }, 'USD 100.00'] normalized to words
// => ['USD 9.00', 'USD 50.00', 'USD 100.00']
```

---

# boundary cases

| case | input | output |
| --- | --- | --- |
| zero values | `isIsoPrice.equal('USD 0.00', 'USD 0')` | `true` |
| negative values | `isIsoPrice.greater('USD -5.00', 'USD -10.00')` | `true` (-5 > -10) |
| very large values | `isIsoPrice.greater('USD 999_999_999.99', 'USD 1.00')` | `true` |
| very small values | `isIsoPrice.lesser('USD 0.000_000_001', 'USD 0.000_000_002')` | `true` |
| mixed sign | `isIsoPrice.greater('USD 1.00', 'USD -1.00')` | `true` |
| empty array | `asIsoPrice.sorted([])` | `[]` |
| single element | `asIsoPrice.sorted(['USD 1.00'])` | `['USD 1.00']` |
| all equal | `asIsoPrice.sorted(['USD 1', 'USD 1.00', 'USD 1.000'])` | stable order preserved |
| currency mismatch | `isIsoPrice.greater('USD 1', 'EUR 1')` | throws |
